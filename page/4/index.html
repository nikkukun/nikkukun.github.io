<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="是个蒟蒻，梦想不是造飞机。">
<meta property="og:type" content="website">
<meta property="og:title" content="Nikkukun&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Nikkukun&#39;s Blog">
<meta property="og:description" content="是个蒟蒻，梦想不是造飞机。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="nikkukun">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Nikkukun's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Nikkukun's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/luogu/3750/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_tozuka_kotaro.jpg">
      <meta itemprop="name" content="nikkukun">
      <meta itemprop="description" content="是个蒟蒻，梦想不是造飞机。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkukun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/luogu/3750/" class="post-title-link" itemprop="url">六省联考 2017 分手是祝愿</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-23 23:12:53" itemprop="dateCreated datePublished" datetime="2018-11-23T23:12:53+00:00">2018-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-12 14:16:05" itemprop="dateModified" datetime="2021-06-12T14:16:05+00:00">2021-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" itemprop="url" rel="index"><span itemprop="name">概率与期望</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/show/P3750">Luogu</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/luogu/3750/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/hihocoder/1869/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_tozuka_kotaro.jpg">
      <meta itemprop="name" content="nikkukun">
      <meta itemprop="description" content="是个蒟蒻，梦想不是造飞机。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkukun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hihocoder/1869/" class="post-title-link" itemprop="url">hihocoder1869 Items</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-10 14:08:18" itemprop="dateCreated datePublished" datetime="2018-11-10T14:08:18+00:00">2018-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-12 14:16:05" itemprop="dateModified" datetime="2021-06-12T14:16:05+00:00">2021-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url" rel="index"><span itemprop="name">动态规划</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://hihocoder.com/problemset/problem/1869">hihocoder</a></p>
<p>一句话题面：集合<span class="math inline"> \(S=\{a_i\}\)</span>（<span class="math inline">\(|S| \leq 3 \times 10^5\)</span>），<span class="math inline">\(q\)</span> 次询问求是否存在一个子集<span class="math inline"> \(S_0\subseteq S\)</span>，使得<span class="math inline"> \(\sum_{a_i\in S_0} a_i = r \pmod M\)</span>（<span class="math inline">\(M \leq 3\times 10^5​\)</span>）。</p>
<!---more--->
<h1 id="题解">题解</h1>
<p>具体请参考<a target="_blank" rel="noopener" href="https://media.hihocoder.com/contests/challenge37/sol.pdf">官方题解</a>。</p>
<p>不得不说实在是很妙…… 在原有 DP 基础上为了加速转移，每次只更新可以更新的部分，跳过不能更新的部分。</p>
<p>每次加入元素<span class="math inline"> \(a_i\)</span> 时，在一个可能是转移状态的位置之前，DP 数组的前缀是相同的，因此把 DP 数组当成字符串二分 LCP 长度就可以找到这个位置。不能转移的情况是，更新之前这一位就是<span class="math inline"> \(1\)</span>，也就是没加入<span class="math inline"> \(a_i\)</span> 时就可以取到了。</p>
<p>判断 LCP 用 Hash 即可，树状数组维护。这里学习到一个小技巧：普通 Hash 的 MOD 最好选择它的一个原根作做幂。记得提前算好原根的<span class="math inline"> \(n\)</span> 次幂和对应的逆，不然就会像我一样疯狂 TLE。</p>
<p>复杂度证明十分地巧妙，通过等价代换分析出了总更新次数。另外，这套题的 B 题用了排序不等式证明复杂度。</p>
<h1 id="代码">代码</h1>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">300000</span>+<span class="number">5</span>,MOD=<span class="number">998244353</span>,G=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BITree</span>{</span></span><br><span class="line">    ll t[N];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> p,ll v)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(;p&lt;N;p+=Lowbit(p))</span><br><span class="line">            t[p]=(t[p]+v)%MOD;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">        ll ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;p;p-=Lowbit(p))</span><br><span class="line">            ret=(ret+t[p])%MOD;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">QPow</span><span class="params">(ll bas,ll t)</span></span>{</span><br><span class="line">    ll ret=<span class="number">1</span>;bas%=MOD;</span><br><span class="line">    <span class="keyword">for</span>(;t;t&gt;&gt;=<span class="number">1</span>,bas=bas*bas%MOD)</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1LL</span>)ret=ret*bas%MOD;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Inv</span><span class="params">(ll x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> QPow(x,MOD<span class="number">-2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">BITree t;</span><br><span class="line">ll pow3[N],inv3[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitHash</span><span class="params">()</span></span>{</span><br><span class="line">    pow3[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">        pow3[i]=pow3[i<span class="number">-1</span>]*G%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        inv3[i]=Inv(pow3[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">    ll ret=(t.Query(r)-t.Query(l<span class="number">-1</span>))%MOD;</span><br><span class="line">    ret=ret*inv3[l<span class="number">-1</span>]%MOD;</span><br><span class="line">    <span class="keyword">return</span> (ret+MOD)%MOD;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll det;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> st1,<span class="keyword">int</span> st2,<span class="keyword">int</span> M)</span></span>{</span><br><span class="line">    ll h1=(Hash(st1,st1+M<span class="number">-1</span>)+det)%MOD;</span><br><span class="line">    ll h2=Hash(st2,st2+M<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> h1==h2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSearch</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> st1,<span class="keyword">int</span> st2)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(L&lt;R){</span><br><span class="line">        <span class="keyword">int</span> M=(L+R)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(Check(st1,st2,M))L=M+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R=M;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    InitHash();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    t.Add(<span class="number">1</span>,pow3[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,len;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">        q[<span class="number">0</span>]=<span class="number">0</span>;		<span class="comment">//q: update</span></span><br><span class="line"></span><br><span class="line">        det=<span class="number">0</span>;len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(Check(<span class="number">1</span>,<span class="number">1</span>+a,m-a)==<span class="number">0</span>){</span><br><span class="line">            len=BSearch(len,m-a,<span class="number">1</span>,<span class="number">1</span>+a);</span><br><span class="line">            <span class="keyword">if</span>(f[len]==<span class="number">0</span>&amp;&amp;f[a+len]==<span class="number">1</span>)</span><br><span class="line">                det=(det+pow3[len])%MOD;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                det=(det+MOD-pow3[len])%MOD;</span><br><span class="line">                q[++q[<span class="number">0</span>]]=a+len;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        det=<span class="number">0</span>;len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(Check(m-a+<span class="number">1</span>,<span class="number">1</span>,a)==<span class="number">0</span>){</span><br><span class="line">            len=BSearch(len,a,m-a+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(f[m-a+len]==<span class="number">0</span>&amp;&amp;f[len]==<span class="number">1</span>)</span><br><span class="line">                det=(det+pow3[len])%MOD;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                det=(det+MOD-pow3[len])%MOD;</span><br><span class="line">                q[++q[<span class="number">0</span>]]=len;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=q[<span class="number">0</span>];j++){</span><br><span class="line">            t.Add(q[j],pow3[q[j]]);</span><br><span class="line">            f[q[j]]=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nQ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nQ);</span><br><span class="line">    <span class="keyword">while</span>(nQ--){</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(f[r+<span class="number">1</span>]?<span class="string">"YES\n"</span>:<span class="string">"NO\n"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog-renderer-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_tozuka_kotaro.jpg">
      <meta itemprop="name" content="nikkukun">
      <meta itemprop="description" content="是个蒟蒻，梦想不是造飞机。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkukun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/blog-renderer-test/" class="post-title-link" itemprop="url">blog 渲染测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-04 14:05:55" itemprop="dateCreated datePublished" datetime="2018-11-04T14:05:55+00:00">2018-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-12 14:16:05" itemprop="dateModified" datetime="2021-06-12T14:16:05+00:00">2021-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/" itemprop="url" rel="index"><span itemprop="name">博客建设</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一个测试博客格式与渲染的页面。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/blog-renderer-test/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/reference-to-build-hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_tozuka_kotaro.jpg">
      <meta itemprop="name" content="nikkukun">
      <meta itemprop="description" content="是个蒟蒻，梦想不是造飞机。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkukun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/reference-to-build-hexo/" class="post-title-link" itemprop="url">关于 hexo 的一些参考资料</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-04 14:02:19" itemprop="dateCreated datePublished" datetime="2018-11-04T14:02:19+00:00">2018-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-12 14:16:05" itemprop="dateModified" datetime="2021-06-12T14:16:05+00:00">2021-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE/" itemprop="url" rel="index"><span itemprop="name">博客建设</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一些配置 hexo 和 nexT 时参考的文章。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/blog/reference-to-build-hexo/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/summary/2-sat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_tozuka_kotaro.jpg">
      <meta itemprop="name" content="nikkukun">
      <meta itemprop="description" content="是个蒟蒻，梦想不是造飞机。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkukun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/summary/2-sat/" class="post-title-link" itemprop="url">2-SAT 总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-14T00:00:00+00:00">2017-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-12 14:16:05" itemprop="dateModified" datetime="2021-06-12T14:16:05+00:00">2021-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">算法总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2-SAT（2-satisfiability）即给定一些布尔变量的<strong>或</strong>关系，判断是否有满足所有关系的变量取值。SAT 问题是 NPC 问题，2-SAT 问题是 P 问题。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/summary/2-sat/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/summary/dynamic-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_tozuka_kotaro.jpg">
      <meta itemprop="name" content="nikkukun">
      <meta itemprop="description" content="是个蒟蒻，梦想不是造飞机。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkukun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/summary/dynamic-programming/" class="post-title-link" itemprop="url">动态规划总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-14T00:00:00+00:00">2017-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-12 14:16:05" itemprop="dateModified" datetime="2021-06-12T14:16:05+00:00">2021-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">算法总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>主要说明优化 DP 的一些方法。</p>
<!---more--->
<h2 id="四边形不等式">四边形不等式</h2>
<p>四边形不等式是一个神奇的二元函数的结论，利用它可以得到决策的单调性，从而加速寻找转移状态的时间。然而我对这个东西并没有研究，因此也只能谈一下结论。</p>
<p>对函数<span class="math inline"> \(w_{i,j}\)</span>，若满足</p>
<p><span class="math display">\[w_{i,j}+w_{i',j'}\leq w_{i,j'}+w_{i',j} \quad (i\leq i'\leq j\leq j')\]</span></p>
<p>则函数<span class="math inline"> \(w_{i,j}\)</span> 满足四边形不等式。令<span class="math inline"> \(s_{i,j}\)</span> 表示<span class="math inline"> \(w_{i,j}\)</span> 得到最优值的转移来源，则有：</p>
<p><span class="math display">\[s_{i,j}\leq s_{i,j+1}\leq s_{i+1,j+1} \quad (i\leq j)\]</span></p>
<p>即决策具有单调性。利用这个性质可以缩小决策集合，加速决策时间。但是不等式仅仅<strong>缩小了范围</strong>，并不意味着当一个决策比之前的决策和后一个决策更优时，就不继续考察后面的决策。</p>
<p>（其实还有一个区间包含单调不等式，但是我没看出来有什么用）</p>
<h2 id="斜率优化">斜率优化</h2>
<p>斜率优化是优化一类动态规划的方法，通常的实现是维护一个凸包从而达到<span class="math inline"> \(\mathcal{O}(\log {n})\)</span> 甚至<span class="math inline"> \(\mathcal{O}(1)\)</span> 的转移时间复杂度。维护凸包通常采用单调队列或平衡树。</p>
<h3 id="一般情况">一般情况</h3>
<p>从典型的情况着手。假设我们有一个转移方程：</p>
<p><span class="math display">\[f_i = \min\{-a_i*b_j+c_j\}+d_i \quad (0\leq j&lt;i)\]</span></p>
<p>很明显，这个方程在朴素的情况下需要对每个<span class="math inline"> \(i\)</span> 枚举<span class="math inline"> \(j\)</span>，时间复杂度是<span class="math inline"> \(\mathcal{O}(n^2)\)</span> 的。但是我们发现这个方程与<span class="math inline"> \(i\)</span> 和<span class="math inline"> \(j\)</span> 有关的项只有一项，而其他项要么<strong>只与<span class="math inline"> \(i\)</span> 有关</strong>，要么<strong>只与<span class="math inline"> \(j\)</span> 有关</strong>。令<span class="math inline"> \(x=b_j,y=c_j,d_i=t\)</span>，则对确定的<span class="math inline"> \(j\)</span>，<span class="math inline">\(x\)</span> 与<span class="math inline"> \(y\)</span> 都是确定的。假设此时<span class="math inline"> \(j\)</span> 为最优转移。代入有：</p>
<p><span class="math display">\[
\begin{aligned}
f_i&amp;=-a_i*x+y+t \\ \Rightarrow y&amp;=a_i*x+f_i-t
\end{aligned}
\]</span></p>
<p>由于<span class="math inline"> \(t\)</span> 只与<span class="math inline"> \(i\)</span> 相关，因此我们可以认为<span class="math inline"> \(y = a_i x+f_i\)</span>。此时我们相当于在满足<span class="math inline"> \(0\leq j&lt;i\)</span> 的<span class="math inline"> \(j\)</span> 所代表的点集中，找到使得斜率<span class="math inline"> \(k=a_i\)</span> 的直线在<span class="math inline"> \(y\)</span> 轴上的截距最小的点。不难看出这个点只能在点集的下凸包上，否则其他点都没有该点优。因此我们需要维护一个<strong>下凸的点集</strong>（相邻边<strong>斜率递增</strong>）。</p>
<h4 id="排除不必要点">排除不必要点</h4>
<p>考虑在候选点集里，哪些点是不必要的。方便考虑，我们先假设<span class="math inline"> \(a_i\)</span><strong> 非降</strong>，<span class="math inline">\(b_j\)</span><strong> 严格递增</strong>，则插入点是按横坐标顺序排列的。由于斜率非降，我们通过画图可以知道若点<span class="math inline"> \(j\)</span> 最优化了<span class="math inline"> \(i\)</span>，则对<span class="math inline"> \(\forall i'&gt;i\)</span>，其最优转移都不可能在<span class="math inline"> \(j\)</span> 之前的点<span class="math inline"> \(k\)</span> 取到（斜率非降<span class="math inline"> \(\Leftrightarrow\)</span> 极角非降，考虑旋转卡壳的过程对蹱点的单调转移），因此<strong>转移单调</strong>，可以删除<span class="math inline"> \(j\)</span> 前面的点。</p>
<p>再考虑插入新点<span class="math inline"> \(i\)</span> 的情况。如果当前加入了<span class="math inline"> \(i\)</span> 会使得下凸性质被破坏，则当前点集最后一个点必定在下凸的上方，也就不会再被选中，直接删除。这个判断如果直接比较斜率容易出现<strong>精度误差</strong>甚至斜率不存在，我更喜欢用<strong>叉积</strong>计算。</p>
<p>这样，我们相当于在点集开头与结尾维护了下凸性质，并动态删除多余的点。这个数据结构可以采用双端队列，队首就是最佳转移。每个点最多入队出队一次，均摊时间复杂度为<span class="math inline"> \(\mathcal{O}(1)\)</span>。同理，如果函数转移最大值，则需要维护上凸性质。具体维护什么还要由<strong>点集的给出顺序</strong>（即<span class="math inline"> \(x_i\)</span> 的趋势，如逆序给出需要逆序维护凸包）而定。</p>
<h3 id="更一般的情况">更一般的情况</h3>
<p>我们以上维护凸包的讨论是建立在<span class="math inline"> \(a_i\)</span>（斜率）<strong>非降</strong>，<span class="math inline">\(b_j\)</span>（横坐标）<strong>严格递增</strong>的情形上。假如不满足呢？</p>
<h4 id="斜率无序">斜率无序</h4>
<p>斜率无序，则决策单调性不满足，我们需要<strong>二分</strong>找到凸包上的切点。不难看出目标函数的斜率在最佳转移两侧的斜率之间。查找的时间复杂度为<span class="math inline"> \(\mathcal{O}(\log n)\)</span>。</p>
<h4 id="横坐标无序">横坐标无序</h4>
<p>横坐标无序，则不能直接在队尾插入，需要一个能动态维护序列的数据结构 —— 平衡树。查找到要插入的位置后，维护插入点左右的凸包性质。需要特判<strong>点在凸包内</strong>的情况，这样的点不会更新凸包。如果使用了叉积，就不需要考虑重点或重横坐标的情况。</p>
<p>当然如果斜率和横坐标都无序，那就只能考虑平衡树上的凸包维护。注意细节。</p>
<h2 id="练习">练习</h2>
<p>斜率优化的题目我没做很多，不过感觉都是套路（除了<em>诗人小 G</em>）。</p>
<h3 id="基础">基础</h3>
<h4 id="hdu3507-打印文章">HDU3507 打印文章</h4>
<p>令<span class="math inline"> \(sumC _i = \sum _{j=1}^i c_j\)</span>，则有：</p>
<p><span class="math display">\[
\begin{aligned}
f_i&amp;= \min / \max\{f_j+(sumC_i-sumC_j + M)^2\} \\
&amp;= \min / \max\{-2*sumC_i*sumC_j-2*sumC_j*M+f_j+sumC_j^2\} + (sumC_i+M)^2\\
\end{aligned}
\]</span></p>
<p>同时维护两个凸包。</p>
<h4 id="hnoi2008-玩具装箱">HNOI2008 玩具装箱</h4>
<p>令<span class="math inline"> \(sumC _i = \sum _{j=1}^i c_j\)</span>，则有</p>
<p><span class="math display">\[f_i = \min\{f_j+(i-j-1+sumC_i-sumC_j - L)^2\}\]</span></p>
<p>发现<span class="math inline"> \(i\)</span> 有两个变化量<span class="math inline"> \(i\)</span> 与<span class="math inline"> \(sumC_i\)</span>，不好处理。但是我们能够合并。重新定义<span class="math inline"> \(sumC_i=sumC_i+i\)</span>，则：</p>
<p><span class="math display">\[f_i = \min \{f_j+(sumC_i-sumC_j -L-1)^2\}\]</span></p>
<p>展开式子维护下凸包。</p>
<h4 id="zjoi2007-仓库建设">ZJOI2007 仓库建设</h4>
<p>维护下凸包。题目应该有特判：只要最后的工厂是空的，就不用都运到最后一个工厂，这样费用反而会变小。不过数据没有这种坑点，因此直接输出<span class="math inline"> \(f_n\)</span> 也没问题。</p>
<h4 id="ceoi2004-锯木厂选址">CEOI2004 锯木厂选址</h4>
<p>不用随机算法就水水的。枚举第二个厂<span class="math inline"> \(i\)</span> 与第一个厂<span class="math inline"> \(j\)</span>，化好式子之后发现<span class="math inline"> \(x\)</span> 是递增的，斜率是非降的，直接队列就可以，不需要平衡树。</p>
<h3 id="进阶">进阶</h3>
<h4 id="sdoi2012-任务安排">SDOI2012 任务安排</h4>
<p>这个题明显有后效性，每次分配一段工作就对后面的完成时间增加<span class="math inline"> \(S\)</span>。我们发现对确定的分段<span class="math inline"> \(i\)</span>，其对后面的影响（假设对自己的影响已经计算了）是确定的值<span class="math inline"> \(S*\sum_{j=i+1}^n\)</span>，因此如果我们<strong>提前计算</strong>影响，就可以消除后效性。</p>
<p>令<span class="math inline"> \(sumT_i=\sum_{j=1}^i T_j,sumF_i=\sum_{j=1}^i F_j\)</span>，则：</p>
<p><span class="math display">\[f_i = \min\{f_j+[sumT_i+S*(sumF_n-sumF_j)]*(sumF_i-sumF_j)\}\]</span></p>
<p>明显展开后<span class="math inline"> \(x = sumF_j,k_i=sumT_i\)</span>，然而坑点是有<span class="math inline"> \(t\leq0\)</span> 的数据，<span class="math inline">\(sumT_i\)</span> 不一定递增。需要二分寻找最优转移。</p>
<h4 id="bsoj1517-斜率优化">BSOJ1517 斜率优化</h4>
<p>题意：给定<span class="math inline"> \(a,b\)</span> 数组与<span class="math inline"> \(f_i= \begin{cases} 0, &amp;i=0 \\ \min\{f_j-a_i*b_j\}, &amp;0\leq j&lt;i\leq n \end{cases}\)</span>，<span class="math inline">\(minimize\ f_n\)</span>。</p>
<p>坐标和斜率都不单调，上平衡树维护。可以用 Splay，我用的是非旋转式 Treap。比较惊讶于我的寻找是 <code>Split</code>+<code>Merge</code>+<code>BSearch</code>，总时间复杂度为<span class="math inline"> \(\mathcal{O}(n\log ^2n)\)</span>，竟然也跑得过<span class="math inline"> \(n\leq 200000\)</span>，感觉奥妙重重。</p>
<h3 id="高级">高级</h3>
<p>没做过高级的。至少还没做完<em>货币交换</em>。</p>
<h4 id="noi2009-诗人小g">NOI2009 诗人小 G</h4>
<p>明显跟内容无关，我们只需要每一行的长度<span class="math inline"> \(len_i\)</span>。令<span class="math inline"> \(sumLen_i=\sum_{j=1}^i len_j\)</span>，再令<span class="math inline"> \(sumLen_i=sumLen_i+i\)</span>，则有：</p>
<p><span class="math display">\[
f_i = \min\{f_j+|(sumLen_i-sumLenj-1-L)^p|\}
\]</span></p>
<p>对于<span class="math inline"> \(p=2\)</span> 的点就是基础的斜率优化，可以过两个数据点。然而<span class="math inline"> \(p\leq 10\)</span>，没办法斜率优化。打个表发现决策具有单调性，然后我们也可以（通过复杂的）证明得到这个式子满足四边形不等式<span class="math inline"> \(\Leftrightarrow\)</span> 决策具有单调性，就可以维护啦。</p>
<p>具体来说，我们插入时考虑决策<span class="math inline"> \(i\)</span> 可能是哪些状态的最优决策，用<span class="math inline"> \(a_i\)</span> 表示<span class="math inline"> \(i\)</span> 的最优决策的最大值，则不难看出<span class="math inline"> \(a_i\)</span> 是非降的。因为决策单调，决策<span class="math inline"> \(j\)</span> 如果是<span class="math inline"> \(i\)</span> 的最优决策，则<span class="math inline"> \(i\)</span> 后面的所有状态的可能最优决策都更新为<span class="math inline"> \(j\)</span>。我们可以用栈维护<strong>每个决策能更新的状态的起始点</strong>，一个决策一旦被覆盖就不可能再出现。步骤如下：</p>
<ol type="1">
<li>对栈顶元素<span class="math inline"> \(top\)</span> 的起始点<span class="math inline"> \(pos_{top}\)</span> 考察用当前决策<span class="math inline"> \(i\)</span> 是否会更优，是则出栈，否则重复。</li>
<li>此时决策<span class="math inline"> \(i\)</span> 的起始点一定在<span class="math inline"> \((pos_{top},n]\)</span> 之间，二分查找<span class="math inline"> \(pos_i\)</span>。</li>
</ol>
<p>每次寻找最优决策时间二分<span class="math inline"> \(\mathcal{O}(\log n)\)</span>（如果维护队列为<span class="math inline"> \(\mathcal{O}(1)\)</span>），维护栈时每个元素最多出栈入栈一次，平摊<span class="math inline"> \(\mathcal{O}(1)\)</span>，二分<span class="math inline"> \(\mathcal{O}(\log n)\)</span>。所以单次数据复杂度为<span class="math inline"> \(\mathcal{O}(n\log n)\)</span>，完美解决。</p>
<p>不过严格来说，这跟斜率优化没有太大关系，重点在转移单调。</p>
<h2 id="总结">总结</h2>
<p>斜率优化维护一个凸包从而达到<span class="math inline"> \(\mathcal{O}(\log n)\)</span> 甚至<span class="math inline"> \(\mathcal{O}(1)\)</span> 的转移复杂度，从而加速转移。一般需要转移具有单调性，可以通过四边形不等式证明。具体有几个要点：</p>
<ul>
<li><p>转移表达式只与当前状态<span class="math inline"> \(i\)</span> 与候选状态<span class="math inline"> \(j\)</span> 有关，而不与其他变量<span class="math inline"> \(k\)</span> 有关；或与<span class="math inline"> \(k\)</span> 有关，但在<span class="math inline"> \(k\)</span> 确定时<span class="math inline"> \(i\)</span> 只与<span class="math inline"> \(j\)</span> 有关。这样确保了二维平面上每个候选状态点<span class="math inline"> \(j\)</span> 的<strong>存在</strong>。</p></li>
<li><p>斜率优化中，表达式的<span class="math inline"> \(x\)</span> 值为<strong>与<span class="math inline"> \(i\)</span> 相关的<span class="math inline"> \(j\)</span> 的变量</strong>，<span class="math inline">\(y\)</span> 值为<strong>只与<span class="math inline"> \(y\)</span> 相关的变量</strong>。</p></li>
<li><p>斜率无序：二分；横坐标无序：平衡树</p></li>
<li><p>四边形不等式：<span class="math inline">\(w_{i,j}+w_{i',j'}\leq w_{i,j'}+w_{i',j} \quad (i\leq i'\leq j\leq j')\)</span> 满足四边形不等式的式子具有<strong>转移单调性</strong>，可以采用<strong>栈</strong>维护转移集合。要确定一个式子满足决策单调，除了证明通常采用<strong>打表</strong>观察（不一定正确）。</p></li>
<li><p>有后效性的转移可以<strong>提前计算影响</strong>。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/summary/matrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_tozuka_kotaro.jpg">
      <meta itemprop="name" content="nikkukun">
      <meta itemprop="description" content="是个蒟蒻，梦想不是造飞机。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkukun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/summary/matrix/" class="post-title-link" itemprop="url">矩阵总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-14T00:00:00+00:00">2017-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-12 14:16:05" itemprop="dateModified" datetime="2021-06-12T14:16:05+00:00">2021-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">算法总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>矩阵是个很神奇的东西，可惜我涉猎较少，只能浅谈矩阵的应用。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/summary/matrix/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/summary/mobius-inversion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_tozuka_kotaro.jpg">
      <meta itemprop="name" content="nikkukun">
      <meta itemprop="description" content="是个蒟蒻，梦想不是造飞机。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkukun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/summary/mobius-inversion/" class="post-title-link" itemprop="url">莫比乌斯反演总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-14T00:00:00+00:00">2017-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-12 14:16:05" itemprop="dateModified" datetime="2021-06-12T14:16:05+00:00">2021-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">算法总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>莫比乌斯反演是偏序集上的一个反演，不过在此处我们只讨论整数格上的莫比乌斯反演。</p>
<!---more--->
<h1 id="莫比乌斯反演">莫比乌斯反演</h1>
<h2 id="整数格上的莫比乌斯反演">整数格上的莫比乌斯反演</h2>
<p>定义<span class="math inline"> \(\mu\)</span> 函数：</p>
<p><span class="math display">\[
\mu(n)=
\begin{cases}
1,&amp;n=1 \\
(-1)^m,&amp;n=\prod_{i=1}^m p_i^{k_i},\prod_{i=1}^m k_i=1 \\
0,&amp;otherwise\\
\end{cases}
\]</span></p>
<p>函数有两个性质。</p>
<ul>
<li><span class="math inline">\(\mu\)</span> 是积性函数。</li>
<li><span class="math inline">\(\sum_{i=1}^n\mu(i)= \begin{cases} 1,&amp;n=1 \\ 0,&amp;othewise\\ \end{cases}\)</span></li>
</ul>
<p>第一条性质说明<span class="math inline"> \(\mu\)</span> 可以<strong>线性筛</strong>；第二条性质提供了我们一个<strong>当且仅当</strong><span class="math inline"> \(n=1\)</span> 时计数的函数，因此在遇到求<span class="math inline"> \((i,j)=1\)</span> 的问题中通常会用到它。</p>
<p>直接给出代码。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>{</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;i++){</span><br><span class="line">        <span class="keyword">if</span>(!notPri[i])pri[siz++]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;siz&amp;&amp;i*pri[j]&lt;N;j++){</span><br><span class="line">            <span class="keyword">int</span> nxt=i*pri[j];notPri[nxt]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j])mu[nxt]=-mu[i];</span><br><span class="line">            <span class="keyword">else</span> {mu[nxt]=<span class="number">0</span>;<span class="keyword">break</span>;}</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当出现平方因子就退出筛法保证了每个数只会被最小的因子筛去，因此时间复杂度线性。<span class="math inline">\(\mu_i=0\)</span> 的情况是由最小因子筛掉的，而其他情况都是由<span class="math inline"> \(\mu_i=-\mu_j\)</span> 得到的。</p>
<h2 id="反演">反演</h2>
<p>想学习很多反演，但是太菜了只会这个.jpg</p>
<p>以后可能会补吧。</p>
<p>若函数<span class="math inline"> \(f(n),g(n)\)</span> 为数论函数，且满足<span class="math inline"> \(f(n)=\sum_{i|n}g(i)\)</span>，则有：</p>
<p><span class="math display">\[g(n)=\sum_{i|n}f(n)\mu\left(\frac ni\right)=\sum_{i|n}f\left(\frac ni\right)\mu(i)\]</span></p>
<p>若函数<span class="math inline"> \(f(n),g(n)\)</span> 为数论函数，且满足<span class="math inline"> \(f(i)=\sum_{d=1}^{\left\lfloor n/i \right\rfloor}g(i*d)\)</span>，则有：</p>
<p><span class="math display">\[g(i)=\sum_{d=1}^{\left\lfloor n/i \right\rfloor}f(i\times d)\mu(d)\]</span></p>
<p><a target="_blank" rel="noopener" href="https://blog.sengxian.com/algorithms/mobius-inversion-formula">证明</a>略去。事实上两种方法都可以比较方便地运用，一般第一种不需要构造函数，而第二种需要构造函数。</p>
<h3 id="常用反演">常用反演</h3>
<p>定义符号</p>
<p><span class="math display">\[[exp]=
\begin{cases}
1,&amp;exp=true\\
0,&amp;exp=false \\
\end{cases}
\]</span></p>
<p>定义函数<span class="math inline"> \(e(n)=[n==1],id(n)=n\)</span>，则有：</p>
<p><span class="math display">\[
e=\mu \times 1 \\
id=\phi \times 1
\]</span></p>
<p>乘法代表 Dirichlet 卷积。因此反演也可以表示为：</p>
<p><span class="math display">\[f=g \times 1 \Leftrightarrow g=f \times \mu\]</span></p>
<h2 id="应用">应用</h2>
<h3 id="二维gcd计数前缀和">二维 GCD 计数前缀和</h3>
<p>求<span class="math inline"> \(\sum_{i=1}^n \sum_{j=1}^m [(i,j)==k]\)</span> 且<span class="math inline"> \(n\leq m\)</span>。</p>
<h4 id="不使用函数变换的方法">不使用函数变换的方法</h4>
<p>不难发现：</p>
<p><span class="math display">\[
\begin {aligned}
\sum_{i=1}^n \sum_{j=1}^m [(i,j)==k]
=&amp;\sum_{i=1}^n \sum_{j=1}^m \left [\left (\frac ik,\frac jk\right)==1\right]  \\
=&amp;\sum_{i=1}^n \sum_{j=1}^m e\left (\left (\frac ik,\frac jk\right)\right)  \\
=&amp;\sum_{i=1}^n \sum_{j=1}^m \sum_{g|(i,j)} \mu (g)  \\
=&amp;\sum_{i=1}^n \sum_{j=1}^m \sum_{g|i\text {且} g|j} \mu (g)  \\
=&amp; \sum_{g=1}^n\sum_{i=1}^{\left\lfloor n/g\right\rfloor} \sum_{j=1}^{\left\lfloor m/g\right\rfloor} \mu (g)  \\
=&amp; \sum_{g=1}^n \mu (g) \sum_{i=1}^{\left\lfloor n/g \right\rfloor} \sum_{j=1}^{\left\lfloor m/g\right\rfloor}   \\
\end {aligned}
\]</span></p>
<p>而<span class="math inline"> \(\left\lfloor \dfrac ng\right\rfloor\)</span> 只有不超过<span class="math inline"> \(\sqrt{n}\)</span> 种取值，<span class="math inline">\(\left\lfloor \dfrac ng\right\rfloor\)</span> 和<span class="math inline"> \(\left\lfloor \dfrac mg\right\rfloor\)</span> 只有不超过<span class="math inline"> \(\sqrt{n}+\sqrt{m}\)</span> 种取值，因此可以将<span class="math inline"> \([1,n]\)</span> 分成<span class="math inline"> \(\sqrt{n}+\sqrt{m}\)</span> 块，每一块的<span class="math inline"> \(\left\lfloor \dfrac ng\right\rfloor\)</span> 和<span class="math inline"> \(\left\lfloor \dfrac mg\right\rfloor\)</span> 取值都不变，则我们预处理<span class="math inline"> \(\mu\)</span> 后可以对一块区间进行<span class="math inline"> \(\mathrm{O}(1)\)</span> 的统计，总时间复杂度为<span class="math inline"> \(\mathrm{O}(\sqrt{n}+\sqrt{m})\)</span>。</p>
<h4 id="使用函数变换的方法">使用函数变换的方法</h4>
<p>令<span class="math inline"> \(f(k)=\sum_{i=1}^n \sum_{j=1}^m [(i,j)==k]\)</span>，<span class="math inline">\(g(k)=\sum_{i=1}^n \sum_{j=1}^m [k|(i,j)]\)</span>，则<span class="math inline"> \(f(k)\)</span> 就是我们要求的答案。很明显<span class="math inline"> \(k|(i,j) \Leftrightarrow k|i\text {且} k|j\)</span>，因此<span class="math inline"> \(g(k)=\left\lfloor \dfrac nk \right\rfloor \left\lfloor \dfrac mk \right\rfloor\)</span>。</p>
<p>发现<span class="math inline"> \(g(k)=\sum_{d=1}^{\left\lfloor n/k \right\rfloor}f(d \times k)\)</span>，因此有：</p>
<p><span class="math display">\[
\begin{aligned}
f(k)=&amp;\sum_{d=1}^{\left\lfloor n/k \right\rfloor}g(d \times k)\mu(d) \\
=&amp;\sum_{d=1}^{\left\lfloor n/k \right\rfloor}\left\lfloor \dfrac n{dk} \right\rfloor \left\lfloor \dfrac m{dk} \right\rfloor\mu(d)
\end{aligned}
\]</span></p>
<p>令<span class="math inline"> \(n'=\left\lfloor \dfrac nk \right\rfloor,m'=\left\lfloor \dfrac mk \right\rfloor\)</span>，则</p>
<p><span class="math display">\[
\begin{aligned}
f(k)=&amp;\sum_{d=1}^{\left\lfloor n/k \right\rfloor}\left\lfloor \dfrac {n'}d \right\rfloor \left\lfloor \dfrac {m'}d \right\rfloor\mu(d)
\end{aligned}
\]</span></p>
<p>类似上面可以证明<span class="math inline"> \(n',m'\)</span> 的取值个数，因此求解也是<span class="math inline"> \(\mathrm{O}(\sqrt{n}+\sqrt{m})\)</span> 的。</p>
<p>好了，那求了一个区间后，怎么寻找下一个区间？假设我们当前区间开头为<span class="math inline"> \(i\)</span>，并假设下一个区间为<span class="math inline"> \(j\)</span>，则：</p>
<p><span class="math display">\[
\begin{aligned}
\left\lfloor \dfrac {n'}i \right\rfloor &amp;\leq \left\lfloor \dfrac {n'}j  \right\rfloor \\
\Rightarrow \left\lfloor \dfrac {n'}i  \right\rfloor &amp;\leq \dfrac {n'}j \\
\Rightarrow j &amp;\leq \dfrac {n'}{\left\lfloor {n'}/i \right\rfloor} \\
\Rightarrow j &amp;\leq \left\lfloor \dfrac {n'}{\left\lfloor {n'}/i \right\rfloor}\right\rfloor\\
\end{aligned}
\]</span></p>
<p>同理可得<span class="math inline"> \(m\)</span>。因此<span class="math inline"> \(j=\min\left( \left\lfloor \dfrac {n'}{\left\lfloor {n'}/i \right\rfloor} \right\rfloor,\left\lfloor \dfrac {m'}{\left\lfloor {m'}/i \right\rfloor} \right\rfloor\right)\)</span>。这个技巧在很多莫比乌斯反演的题目都用得上。</p>
<h3 id="求约数个数和">求约数个数和</h3>
<p>直接给出结论：</p>
<p>若<span class="math inline"> \(d(n)\)</span> 为<span class="math inline"> \(n\)</span> 的约数个数，则有：</p>
<p><span class="math display">\[
d(nm)=\sum_{i|n} \sum_{j|m} [(i,j)==1]
\]</span></p>
<p>证明不略。假设<span class="math inline"> \(nm=\prod_{i=1}p_i^{x_i},n=\prod_{i=1}p_i^{y_i}\)</span>，则<span class="math inline"> \(m=\prod_{i=1}p_i^{x_i-y_i}\)</span>。</p>
<p>对于<span class="math inline"> \((i,j)=1\)</span>，考虑因子<span class="math inline"> \(p_k\)</span>，则<span class="math inline"> \(i\)</span> 和<span class="math inline"> \(j\)</span> 的<span class="math inline"> \(p_k\)</span> 项指数不能都不为<span class="math inline"> \(0\)</span>。当<span class="math inline"> \(i\)</span> 的<span class="math inline"> \(p_k\)</span> 为<span class="math inline"> \(0\)</span> 时，<span class="math inline">\(j\)</span> 有<span class="math inline"> \(x_k-y_k+1\)</span> 种取值；当<span class="math inline"> \(j\)</span> 的<span class="math inline"> \(p_k\)</span> 为<span class="math inline"> \(0\)</span> 时，<span class="math inline">\(i\)</span> 有<span class="math inline"> \(y_k+1\)</span> 种取值；<span class="math inline">\(i,j\)</span> 的<span class="math inline"> \(p_k\)</span> 项可以都取<span class="math inline"> \(0\)</span>。因此<span class="math inline"> \(i\)</span> 与<span class="math inline"> \(j\)</span> 的<span class="math inline"> \(p_k\)</span> 项有<span class="math inline"> \(x_k+1\)</span> 种二元组<span class="math inline"> \((i,j)\)</span> 的取值，总二元组方案数为<span class="math inline"> \(\prod_{i=1} x_i+1\)</span>，满足约数个数公式。</p>
<p>然后还有个推广的神奇大结论：</p>
<p><span class="math display">\[\sum_{x_1}^{y_1} \sum_{x_2}^{y_2} \cdots \sum_{x_k}^{y_k} d(x_1 x_2 \cdots x_k) = \sum_{x_1}^{y_1} \sum_{x_2}^{y_2} \cdots \sum_{x_k}^{y_k} \prod_{i=1}^{k} \left\lfloor \dfrac{y_i}{x_i} \right\rfloor \prod_{i &lt; j }  [(x_i, x_j)=1]\]</span></p>
<p>太神奇，<a target="_blank" rel="noopener" href="http://www.cnblogs.com/iwtwiioi/p/4986325.html">证明</a>需要二重数学归纳，略过。</p>
<h1 id="杜教筛">杜教筛</h1>
<p>高端，不会。</p>
<h1 id="min-25筛">min-25 筛</h1>
<p>高端，不会。</p>
<h1 id="练习">练习</h1>
<p>莫比乌斯的题目通常能转化为<span class="math inline"> \((i,j)=1\)</span> 的计数问题，而转化为计数问题我们就容易通过分块求解了。</p>
<h2 id="基础">基础</h2>
<h3 id="poi2007-zap">POI2007 Zap</h3>
<p>二维 GCD 计数前缀和。</p>
<h3 id="haoi2011-problem-b">HAOI2011 Problem b</h3>
<p><em>POI2007 Zap</em> 的加强版，容斥原理加加减减就好了。</p>
<h3 id="bzoj2820-yy的gcd">BZOJ2820 YY 的 GCD</h3>
<p>仍然是二维 GCD 计数前缀和，不过需要<span class="math inline"> \((i,j)\)</span> 为质数。只要预处理质数的<span class="math inline"> \(\mu\)</span> 前缀和就好了。</p>
<h3 id="sdoi2008-仪仗队">SDOI2008 仪仗队</h3>
<p>不被挡住即行列<span class="math inline"> \((i,j)=1\)</span>（从<span class="math inline"> \(0\)</span> 标号），因此答案为<span class="math inline"> \((\sum_{i=1}^n \sum_{i=1}^n [(i,j)==1])+2\)</span>（<span class="math inline">\(2\)</span> 个是<span class="math inline"> \((0,1),(1,0)\)</span>）。最终化为<span class="math inline"> \((\sum_{g=1}^n \mu(g)\left\lfloor \dfrac ng\right\rfloor ^2)+2\)</span>，分块求解。</p>
<h2 id="进阶">进阶</h2>
<h3 id="sdoi2015-约数个数和">SDOI2015 约数个数和</h3>
<p>是道好题，然而需要结论。</p>
<p>令<span class="math inline"> \(n'=\dfrac ng,m'=\dfrac mg\)</span>，则</p>
<p><span class="math display">\[
\begin{aligned}
\sum_{i=1}^n \sum_{j=1}^m d(ij)
=&amp;\sum_{i=1}^n \sum_{j=1}^m [(i,j)==1] \\
=&amp;\sum_{i=1}^n \sum_{j=1}^m {\left\lfloor \dfrac ni\right\rfloor}{\left\lfloor \dfrac mj\right\rfloor} \sum_{g|(i,j)}\mu(g) \\
=&amp;\sum_{g=1}^n\mu(g)\sum_{i=1}^{\left\lfloor n/g\right\rfloor} \sum_{j=1}^{\left\lfloor m/g\right\rfloor} \dfrac n{ig} \dfrac m{jg} \\
=&amp;\sum_{g=1}^n\mu(g)\sum_{i=1}^{n'} \sum_{j=1}^{m'} \dfrac {n'}i \dfrac{m'}j \\
=&amp;\sum_{g=1}^n\mu(g)\sum_{i=1}^{n'} \dfrac {n'}i\sum_{j=1}^{m'}  \dfrac{m'}j \\
\end{aligned}
\]</span></p>
<p>然后就可以预处理<span class="math inline"> \(f(n)=\sum_{i=1}^n \dfrac ni​\)</span> 的值，每次询问就可以分块解决。之所以要预处理<span class="math inline"> \(f(n)​\)</span>，是因为在倒数第二步时如果采用直接计算<span class="math inline"> \(\sum_{i=1}^{n'} \sum_{j=1}^{m'} \dfrac {n'}i \dfrac{m'}j​\)</span> 开销是很大的。但如果我们能预处理，就能做到<span class="math inline"> \(\mathrm{O}(1)​\)</span> 计算。</p>
<p>预处理时间复杂度<span class="math inline"> \(\mathrm{O}(n\sqrt{n})\)</span>，单次询问时间复杂度<span class="math inline"> \(\mathrm{O}(\sqrt{n})\)</span>。</p>
<h3 id="hnmtc20155-lucas的数论">HNMTC2015#5 Lucas 的数论</h3>
<p>发现是 <em>SDOI2015 约数个数和</em>的单询问加强版本，上面对<span class="math inline"> \(\mu\)</span> 前缀和的<span class="math inline"> \(\mathrm{O}(n)\)</span> 时间复杂度已经不能满足我们了。</p>
<p>式子最终可以推成这样：</p>
<p><span class="math display">\[\sum_{g=1}^n\mu(g) d(n')^2 \]</span></p>
<p>单次<span class="math inline"> \(f(n')\)</span> 可以分块求。假设我们预处理好了 μ 的前缀和，时间复杂度就是<span class="math inline"> \(\mathrm{O}(\sqrt{n})\)</span> 的。这里就有个求<span class="math inline"> \(μ\)</span> 的前缀和<span class="math inline"> \(sum\)</span> 的奇技淫巧了：</p>
<p><span class="math display">\[sum(n)=1-\sum_{i=2}^n sum(\left\lfloor \dfrac ni \right\rfloor)\]</span></p>
<p>递归求解。注意这也是能分块的，因此一层的时间为<span class="math inline"> \(\mathrm{O}(\sqrt{n})\)</span>，据说没有记忆化搜索时计算一次的时间复杂度为<span class="math inline"> \(\mathrm{O}(n^{\frac 23})\)</span>。不过事实上我们可以记忆化搜索，或者线筛预处理出<span class="math inline"> \(n\leq 5000000\)</span>（测试得到这个效率比较高）的<span class="math inline"> \(\mu\)</span> 前缀和减少计算。</p>
<p>总时间复杂度未知，不过测试极限数据还是挺极限的。</p>
<h2 id="高级">高级</h2>
<p>没做过什么高级的。</p>
<h1 id="总结">总结</h1>
<p>莫比乌斯反演基本上离不开 GCD 和两个累和符号，而且重点往往是把式子化成统计 GCD=1 个数的形式，并反演求解。求解一般通过<strong>分块</strong>和预处理<span class="math inline"> \(\mu\)</span> 前缀和的方式<span class="math inline"> \(\mathrm{O}(\sqrt{n})\)</span> 求和。</p>
<ul>
<li><p><span class="math inline">\(e=\mu \times 1,id=\phi \times 1\)</span></p></li>
<li><p><span class="math inline">\(\mu\)</span> 函数的性质：</p>
<ul>
<li><span class="math inline">\(\mu\)</span> 是积性函数。</li>
<li>$_{i=1}^n(i)=
<span class="math display">\[\begin{cases}
  1,&amp;n=1 \\
  0,&amp;othewise\\
  \end{cases}\]</span>
$</li>
</ul></li>
<li><p><span class="math inline">\(\mu\)</span> 的神奇前缀和计算：<span class="math inline">\(sum(n)=1-\sum_{i=2}^n sum(\left\lfloor \frac ni \right\rfloor)\)</span></p></li>
<li><p> 当待分块函数（如<span class="math inline"> \(\mu\)</span>）可以单独提出<strong>预处理</strong>时，可以通过此降低时间复杂度。</p></li>
<li><p>若多次询问中，分块区域下含有 GCD 的枚举值<span class="math inline"> \(g\)</span> 和<span class="math inline"> \(i\)</span> 或<span class="math inline"> \(j\)</span> 之一，可以通过枚举<span class="math inline"> \(ig\)</span> 或<span class="math inline"> \(jg\)</span>，再枚举<span class="math inline"> \(g\)</span> 加速。（说法很意识流，详见<a target="_blank" rel="noopener" href="https://blog.sengxian.com/algorithms/mobius-inversion-formula">莫比乌斯反演简要笔记 - GCD 的幂</a>）</p></li>
<li><p>积性函数有时不好证明，可以打表观察。重点观察幂和质数的值。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/summary/network-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_tozuka_kotaro.jpg">
      <meta itemprop="name" content="nikkukun">
      <meta itemprop="description" content="是个蒟蒻，梦想不是造飞机。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkukun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/summary/network-flow/" class="post-title-link" itemprop="url">网络流总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-14T00:00:00+00:00">2017-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-12 14:16:05" itemprop="dateModified" datetime="2021-06-12T14:16:05+00:00">2021-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">算法总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>网络流，就是一张有向图中给每一边分配一个容量，流可以沿着有容量的边移动。对一个给定的网络，其一个可行流为从源点到汇点的一种流量方案。</p>
<!---more--->
<p>网络流问题就是解决最大流、可行流、费用流等抽象问题的一种模型。对一个可行流来说，它有如下特性：</p>
<ul>
<li>除了源汇点外，每一个点的<strong>入流与出流相等</strong></li>
<li>经过每条边的流量<strong>不超过该边容量上限</strong></li>
</ul>
<p>则最大流就是到达汇点的流量最多的一个可行流，它也满足上述性质。</p>
<p>## 最大流</p>
<p>求最大流可以采用 Dinic、SAP、ISAP 等算法，但我们主要介绍 Dinic。Dinic 算法分为<strong>寻找分层图</strong>与<strong>增广</strong>两个部分。下面不加解释地放上 Dinic 的代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span>{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span><span class="keyword">int</span> v,res;};</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edg;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[V];</span><br><span class="line">    <span class="keyword">int</span> st,ed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> cap)</span></span>{</span><br><span class="line">        edg.push_back((Edge){v,cap});</span><br><span class="line">        edg.push_back((Edge){u,<span class="number">0</span>});</span><br><span class="line">        <span class="keyword">int</span> siz=edg.size();</span><br><span class="line">        a[u].push_back(siz<span class="number">-2</span>);</span><br><span class="line">        a[v].push_back(siz<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dep[V];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="built_in">memset</span>(dep,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(st);dep[st]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">            <span class="keyword">int</span> u=q.front();q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a[u].size();i++){</span><br><span class="line">                Edge e=edg[a[u][i]];</span><br><span class="line">                <span class="keyword">if</span>(dep[e.v]==<span class="number">-1</span>&amp;&amp;e.res&gt;<span class="number">0</span>)</span><br><span class="line">                    q.push(e.v),dep[e.v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dep[ed]!=<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur[V];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> minF)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(u==ed||minF==<span class="number">0</span>)<span class="keyword">return</span> minF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmpF,sumF=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[u];i&lt;a[u].size();i++){</span><br><span class="line">            Edge &amp;e=edg[a[u][i]];</span><br><span class="line">            <span class="keyword">if</span>(dep[e.v]==dep[u]+<span class="number">1</span>&amp;&amp;(tmpF=DFS(e.v,min(minF,e.res)))&gt;<span class="number">0</span>){</span><br><span class="line">                e.res-=tmpF,edg[a[u][i]^<span class="number">1</span>].res+=tmpF;</span><br><span class="line">                sumF+=tmpF;minF-=tmpF;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(minF==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sumF;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(BFS()){</span><br><span class="line">            <span class="built_in">memset</span>(cur,<span class="number">0</span>,<span class="keyword">sizeof</span>(cur));</span><br><span class="line">            ret+=DFS(st,INF);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码用残量表示边的流量数据。对这份代码的解释很容易在网络上找到，在此不做赘述，而只点出实际写时的易错点：</p>
<ul>
<li>寻找分层图时，<strong>不能经过残量为 0 的边</strong>。</li>
<li>利用当前弧结构保存时，每一次寻找增广路前要<strong>清零</strong>。并且寻找增广路时要使用<strong>引用</strong>来更新当前弧。</li>
<li>寻找增广路时要对当前边进行修改，因此要对边使用<strong>引用</strong>而不能单纯复制内容</li>
<li>对边的四个操作要保证修改的<strong>对象</strong>和<strong>数值</strong>是否正确</li>
<li>如果流量为 double 类型，需要 DCmp 判断是否为 0，而不能直接与 0 比较</li>
</ul>
<p>这是一些很 naive 且很容易忘记的错误。放出以警示自己。</p>
<p>### 带上下界的流</p>
<p>带上界的流一般都采用拆点的方式建图来保证其上下界功能。考虑好必须经过的流量是哪些，可以经过的流量是哪些。</p>
<p>#### 带上下界可行流</p>
<p>##### 无源汇</p>
<p>对于 $E = (u , v) <span class="math inline">\(，若其流量限定为 \)</span> [low , upp]$，则我们可以先考虑特殊情况。</p>
<ul>
<li>没有下界：普通的网络流，从<span class="math inline"> \(u\)</span> 向<span class="math inline"> \(v\)</span> 连容量为<span class="math inline"> \(upp\)</span> 的边。</li>
<li>没有上界：<span class="math inline">\(u\)</span> 节点必须输出<span class="math inline"> \(low\)</span> 流量，<span class="math inline">\(v\)</span> 节点必须流入<span class="math inline"> \(low\)</span> 流量。根据这个条件，可以考虑从<span class="math inline"> \(u\)</span> 向<span class="math inline"> \(t\)</span> 连流量为<span class="math inline"> \(low\)</span> 的边，从<span class="math inline"> \(s\)</span> 向<span class="math inline"> \(v\)</span> 连流量为<span class="math inline"> \(low\)</span> 的边，这样就满足了上述条件。</li>
</ul>
<p>我们发现这两个不互相干扰，一起使用即可。明显，整个网络拥有一个可行流的等价条件是，新增的下界边都满流，否则没有可行流。</p>
<p>由于新网络入流与出流相等，而无源汇的网络满足流量平衡，因此 s 的出流等于 t 的入流，也就满足了新增加的边如果从<span class="math inline"> \(s\)</span> 得到了流量，则一定跑到了<span class="math inline"> \(t\)</span>，而不会中途消失。此时 t 的最大流就是经过这些下界边的总流量。</p>
<p>##### 有源汇</p>
<p>从<span class="math inline"> \(t\)</span> 向<span class="math inline"> \(s\)</span> 连一条容量为<span class="math inline"> \(\infty\)</span> 的边，这样网络就变成无源汇的上下界，跑可行流即可。之所以需要变成无源汇而不能拆边后直接跑，是因为无源汇的网络做法考虑了流量平衡，而有源汇的网络明显源汇是不平衡的。如果不连 $(t , s) <span class="math inline">\(的边，那么改建后原网络的 \)</span>s$ 根本就没有流量。这很明显不可行。</p>
<p>#### 有源汇带上下界最大流</p>
<p>##### 普通做法</p>
<p>我们的立足点是无源汇上下界可行流的求法，因此考虑把有源汇先转成无源汇。按照无源汇可行流的方法建图并跑最大流，得到的是一个原图的可行流，此时的下界应该是填满的（显然，不填满就连可行流都没有）。在残余网络上从原图的<span class="math inline"> \(S\)</span> 到<span class="math inline"> \(T\)</span> 跑最大流就是答案。（当然我不是很理解。）</p>
<p>##### 二分做法</p>
<p>我们仍转换为无源汇，但是设从<span class="math inline"> \(T\)</span> 到<span class="math inline"> \(S\)</span> 的边有下界<span class="math inline"> \(x\)</span>，并跑无源汇可行流。明显，如果新图具有可行流，则说明原图能有<span class="math inline"> \(x\)</span> 的流量从<span class="math inline"> \(S\)</span> 到达<span class="math inline"> \(T\)</span>，否则没有。这个性质可以二分。</p>
<p>#### 带上下界最小流</p>
<p>如果不带上下界，则最小流就是零流，没有什么好求的。</p>
<p>##### 普通做法</p>
<p>考虑转化为无源汇，但这次我们不连接从<span class="math inline"> \(T\)</span> 到<span class="math inline"> \(S\)</span> 的边，直接跑<span class="math inline"> \(SuperS\)</span> 到<span class="math inline"> \(SuperT\)</span> 的最大流。再加上从<span class="math inline"> \(S\)</span> 到<span class="math inline"> \(T\)</span> 的边，从<span class="math inline"> \(SuperS\)</span> 到<span class="math inline"> \(SuperT\)</span> 跑一次最大流。若从<span class="math inline"> \(S'\)</span> 出发的边满流，则<span class="math inline"> \(( T , S )\)</span> 的流量为最小流，反之无解。（当然我不是很理解。）</p>
<p>##### 二分做法</p>
<p>我们仍转换为无源汇，但是设从<span class="math inline"> \(T\)</span> 到<span class="math inline"> \(S\)</span> 的边有下界<span class="math inline"> \(x\)</span>，并跑无源汇可行流。明显，如果新图具有可行流，则说明原图能有<span class="math inline"> \(x\)</span> 的流量从<span class="math inline"> \(S\)</span> 到达<span class="math inline"> \(T\)</span>，否则没有。这个性质可以二分。</p>
<p>#### 总结</p>
<p>我们所有上下界流的基础都是建立在上下界无源汇可行流上，因此这个模型的转换是很重要的。另外，上下界最大 / 最小流的二分解法虽然比普通解法多出一个<span class="math inline"> \(\log\)</span>，但是却很容易理解。实际运用上应该是足够的。</p>
<p>## 最小割</p>
<p>流网络 $ G = (V , E) <span class="math inline">\(的割（Cut）\)</span> [ S , T ] <span class="math inline">\(将点集 \)</span> V <span class="math inline">\(划分为 \)</span> S <span class="math inline">\(和 \)</span> T ( T = V − S )<span class="math inline">\(两个部分，使得源 \)</span> s ∈ S <span class="math inline">\(且汇 \)</span>t ∈ T <span class="math inline">\(。符号 \)</span> [ S , T ] <span class="math inline">\(代表一个边集合 \)</span> { u , v | u , v ∈ E , u ∈ S , v ∈ T } <span class="math inline">\(。割 \)</span> [ S , T ] <span class="math inline">\(的容量（Capacity）定义为 \)</span> c ( S , T ) <span class="math inline">\(，一般记为 \)</span> c [S , T] $。一个网络的最小割也就是该网络中容量最小的割。（定义来自<em>《最小割模型在信息学竞赛中的应用》 胡伯涛</em>）</p>
<p>注意边集中方向为<span class="math inline"> \(T\to S\)</span> 的边的容量不计算在割集内。即最小割的容量只为<strong>顺着</strong><span class="math inline"> \(S\to T\)</span><strong> 到达的边</strong>的容量和。</p>
<p>最小割拥有一些不错的性质：</p>
<ul>
<li>最小割将点集分割成两个部分，且最小割只包含了两端点属于不同点集的边的容量</li>
<li><strong>最大流最小割定理：一个网络中的最大流等于最小割</strong></li>
</ul>
<p>第二个性质很重要，它给了我们一个求最小割的方法。而第一个性质给了我们一个转换模型的思路。我们给出如下性质：</p>
<ul>
<li>最小割一定是最大流中的满流边，但满流边不一定是最小割中的边</li>
</ul>
<p>这个性质的反例可以在论文中找到。因此寻找最小割边时，需要<strong>从源点 DFS 顺着有残量的边遍历</strong>，则两端点只被遍历一个的边为最小割边。注意这个有残量的边包括网络中的反边，有些点可能能从反边被到达，因此需要 DFS 而不能单独认为满流边就是最小割边。</p>
<p>### 平面图最小割</p>
<p>可以参考论文<em>《两极相通 —— 浅析最大 — 最小定理在信息学竞赛中的应用》周冬</em>。</p>
<p>平面图的对偶图：把平面图的面当点，连接两个面的边当两个点的边的图。平面图有不错的性质：</p>
<ul>
<li><strong>欧拉公式：顶点数 $ + <span class="math inline">\(面数 \)</span> - <span class="math inline">\(边数 \)</span> = 2$</strong></li>
<li> 平面图的对偶图也是一个平面图</li>
</ul>
<p>对一个源汇点都在无界面的边界的网络，如何根据平面图求它的最小割？我们从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 连接新边创建出附加面，并对这个图创建对偶图，其中<span class="math inline"> \(S'\)</span> 和<span class="math inline"> \(T'\)</span> 为对偶图在附加面与无界面的点。则我们画个图就能发现，<strong>$S' <span class="math inline">\(到 \)</span> T'$ 的一条路径就是原图的一个割</strong>。因此原图的最小割相当于新图的最短路径。</p>
<p>我们得到一个感受：当原问题不好入手时，考虑它的对偶问题。</p>
<p>### 最大权闭合图</p>
<p>这类题目是求具有依赖关系的最大权子图：选择 A 会有一定权值，但同时要选择 B 和 C，它们也会产生权值，这样的关系构成一张有向图。选择有向图的一个子图，使得若<span class="math inline"> \(v\)</span> 在点集，则<span class="math inline"> \(v\)</span> 的出边指向的点也在点集。</p>
<p>对这类题目的详解在论文有。此处只阐明算法：</p>
<ol type="1">
<li>对原图的所有边容量赋为<span class="math inline"> \(\infty\)</span></li>
<li> 从<span class="math inline"> \(S\)</span> 向正权点连权值为<span class="math inline"> \(w\)</span> 的边</li>
<li>从负权点向<span class="math inline"> \(T\)</span> 链权值为<span class="math inline"> \(-w\)</span> 的边</li>
<li>最大权闭合子图 = 正权点权和 - 新图最小割</li>
</ol>
<p>## 二分图最大匹配</p>
<p>二分图本身就有一个两端属于不同点集的边集，因此二分图常常被询问最大匹配。最大匹配即，选定一个边集，使得边集中的所有点不相交。二分图的最大匹配有<span class="math inline"> \(\mathrm{O}(nm)\)</span> 的匈牙利算法（Hungarian Algorithm），非二分图的最大匹配需要带花树算法（Blossom Algorithm）。</p>
<p>不加注释地给出匈牙利算法代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> vst[N];<span class="keyword">int</span> lnk[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=nV;v++)</span><br><span class="line">        <span class="keyword">if</span>(g[u][v]&amp;&amp;!vst[v]){</span><br><span class="line">            vst[v]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!lnk[v]||DFS(lnk[v])){</span><br><span class="line">                lnk[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nV;i++){</span><br><span class="line">    <span class="built_in">memset</span>(vst,<span class="number">0</span>,<span class="keyword">sizeof</span>(vst));</span><br><span class="line">    <span class="keyword">if</span>(DFS(i))ans++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个算法给出的是邻接矩阵做法，我们可以很轻易地改为邻接表。需要注意的点：</p>
<ul>
<li>每次开始搜索前，<strong>清空访问数组</strong></li>
<li>只有<strong>没有访问</strong>的节点可以操作</li>
</ul>
<p>## 图的性质</p>
<p>明确以下概念：</p>
<ul>
<li>点相关
<ul>
<li>最小点覆盖</li>
<li>最大独立集</li>
<li>最小点权覆盖</li>
<li>最大点权独立集</li>
</ul></li>
<li>边相关
<ul>
<li>最小边覆盖</li>
<li>最大匹配</li>
</ul></li>
</ul>
<p>这些概念都可以在论文中找到具体定义，但我们重点讨论它们的性质：</p>
<ul>
<li>最大匹配数<span class="math inline"> \(+\)</span> 最小边覆盖数<span class="math inline"> \(=\)</span> 顶点数（条件：联通图）</li>
<li>最大独立集<span class="math inline"> \(+\)</span> 最小点覆盖数<span class="math inline"> \(=\)</span> 顶点数</li>
<li> König 定理：最大匹配数<span class="math inline"> \(=\)</span> 最小点覆盖（条件：二分图）</li>
<li>最大流<span class="math inline"> \(=\)</span> 最小割</li>
<li>最小割<span class="math inline"> \(=\)</span> 最小点权覆盖集（条件：二分图）</li>
<li>最小点权覆盖集数<span class="math inline"> \(+\)</span> 最大点权独立集数<span class="math inline"> \(=\)</span> 顶点数（条件：二分图）</li>
</ul>
<p>大部分性质都可以概括为：最值 $ = <span class="math inline">\(最值，最小 \)</span> + <span class="math inline">\(最大 \)</span> = ​$ 顶点数。后三条可以得到一个计算最大点权独立集的有效算法。具体的讨论和证明可以参考<em>《两极相通 —— 浅析最大 — 最小定理在信息学竞赛中的应用》周冬</em>。</p>
<p>## 最小费用最大流</p>
<p>给网络中的每一个边一条边权，求使得最大流的情况下的最小费用。下面不加注释地给出代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dinic</span>{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span><span class="keyword">int</span> v,w,res;};</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edg;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[V];</span><br><span class="line">    <span class="keyword">int</span> st,ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> cap)</span></span>{</span><br><span class="line">    edg.push_back((Edge){v,w,cap});</span><br><span class="line">    edg.push_back((Edge){u,-w,<span class="number">0</span>});</span><br><span class="line">    <span class="keyword">int</span> siz=edg.size();</span><br><span class="line">    a[u].push_back(siz<span class="number">-2</span>);</span><br><span class="line">    a[v].push_back(siz<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[V],pa[V],det[V];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> inQ[V];</span><br><span class="line">    <span class="built_in">memset</span>(inQ,<span class="number">0</span>,<span class="keyword">sizeof</span>(inQ));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;q.push_back(st);</span><br><span class="line">    dis[st]=<span class="number">0</span>,inQ[st]=<span class="number">1</span>,det[st]=INF,pa[st]=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()){</span><br><span class="line">        <span class="keyword">int</span> u=q.front();q.pop_front();inQ[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a[u].size();i++){</span><br><span class="line">            Edge &amp;e=edg[a[u][i]];</span><br><span class="line">            <span class="keyword">if</span>(e.res&gt;<span class="number">0</span>&amp;&amp;dis[e.v]&gt;dis[u]+e.w){</span><br><span class="line">                dis[e.v]=dis[u]+e.w;</span><br><span class="line">                det[e.v]=min(det[u],e.res);</span><br><span class="line">                pa[e.v]=a[u][i];</span><br><span class="line">                <span class="keyword">if</span>(!inQ[e.v]){</span><br><span class="line">                    <span class="keyword">if</span>(!q.empty()&amp;&amp;dis[q.front()]&gt;=dis[e.v])q.push_front(e.v);</span><br><span class="line">                    <span class="keyword">else</span> q.push_back(e.v);</span><br><span class="line">                    inQ[e.v]=<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dis[ed]!=INF;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Augment</span><span class="params">(<span class="keyword">int</span> &amp;w)</span></span>{</span><br><span class="line">    w+=dis[ed]*det[ed];</span><br><span class="line">    <span class="keyword">int</span> u=ed;</span><br><span class="line">    <span class="keyword">while</span>(u!=st){</span><br><span class="line">        edg[pa[u]].res-=det[ed];</span><br><span class="line">        edg[pa[u]^<span class="number">1</span>].res+=det[ed];</span><br><span class="line">        u=edg[pa[u]^<span class="number">1</span>].v;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlowMinCost</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(SPFA())Augment(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要点：</p>
<ul>
<li>增广过程与 SPFA 相似，但仍要注意<strong>只有有残量的边可以通过</strong>。</li>
<li>SPFA 过程注意是否出队入队，是否取消标记，是否入对位置正确。</li>
</ul>
<p>### 费用流拆边</p>
<p>一条边所花费的费用是随流量线性增长。如果呈二次增长，甚至三次增长呢？需要拆边。</p>
<p>假设 $f <span class="math inline">\(为流量，\)</span>cap <span class="math inline">\(为边容量，\)</span>w = f ^ 2 <span class="math inline">\(为费用，则当 \)</span> f = 1 <span class="math inline">\(时 \)</span> w = 1 <span class="math inline">\(，\)</span> f = 2 <span class="math inline">\(时 \)</span> w = 4<span class="math inline">\(，\)</span> f = 3 <span class="math inline">\(时 \)</span> w = 9 <span class="math inline">\(。我们把边拆为 \)</span> cap $ 条，每条容量是<span class="math inline"> \(1\)</span>，费用分别是<span class="math inline"> \(1,3,5,\dots\)</span> 则不难发现在流量相同时，费用会选择最小的 $ f <span class="math inline">\(条，而这 \)</span> f <span class="math inline">\(条的费用加起来刚好为 \)</span> w= f ^ 2$。当流量呈更复杂的多项式时，可以利用导数将边拆分。但很明显拆边有前提：流量必须是<strong>整数</strong>，多项式导数必须<strong>递增</strong>。</p>
<p>### 带权二分图匹配</p>
<p>如果有权，则可以给边赋权用费用流求解匹配。从<span class="math inline"> \(S\)</span> 向<span class="math inline"> \(X\)</span> 集合、从<span class="math inline"> \(Y\)</span> 集合向<span class="math inline"> \(T\)</span> 连权值为点权、容量为<span class="math inline"> \(1\)</span> 的边，跑最大流最小费用即可。</p>
<p>## 练习</p>
<p>### 最大流</p>
<p>####USACO4.2.1 草地排水</p>
<p>最大流模板题目。</p>
<p>####BSOJ1721 上下界可行流 &amp; BSOJ1723 上下界最大流 &amp; BSOJ1725 上下界最小流</p>
<p>上下界网络流的练习题。</p>
<p>####BSOJ2547 网络流 24 题 - 6 最长递增子序列</p>
<p>第二问可以考虑每个点只能被选一次，并且假设当前节点结尾的 LIS 为 $ d <span class="math inline">\(，则当前节点只能向后面 LIS 为 \)</span> d + 1 $ 的节点（否则不是 LIS）连容量为<span class="math inline"> \(1\)</span> 的边。最后 $ S <span class="math inline">\(连 \)</span> d $ 为<span class="math inline"> \(1\)</span> 的点，$ d <span class="math inline">\(为全局 LIS 的点向 \)</span>T<span class="math inline">\(连，跑最大流即可。第三问只需要修改部分点流量为 \)</span>$。</p>
<p>####SDOI2015 星际战争</p>
<p>二分答案判断最大流是否足够。注意精度。</p>
<p>### 二分图最大匹配</p>
<p>####SCOI2015 小凸玩矩阵</p>
<p>二分答案<span class="math inline"> \(ans\)</span>，<span class="math inline">\(X\)</span> 集合为行，<span class="math inline">\(Y\)</span> 集合为列，选中一个元素等于匹配两个点，每次只能选择小于等于<span class="math inline"> \(ans\)</span> 的元素。判断这些元素（匹配）是否有 $ (n - k + 1) <span class="math inline">\(个。注意第 \)</span>k<span class="math inline">\(大而不是第 \)</span>k$ 小。</p>
<p>####USACO2005NovGold Asteroids</p>
<p>有行星的位置连接一条边，求最小点覆盖。可转化为最大匹配。</p>
<p>####USACO2005JanGold 泥泞的牧场</p>
<p>注意到每个点只能被横行或纵列覆盖（可以同时覆盖）。对于连续的泥泞，我们一块木板盖上是最好的。因此我们可以把图分块。横向的分块与纵向的分块编号后，一个泥泞就只能对应一条横向与一条纵向分块的交点了。</p>
<p>题目相当于转化为选择尽量少的分块，使得每个交点都被覆盖。如果把分块变成左右两端的点，交点变为它们之间的边，则原题目化为最小点覆盖。为什么可以转化？我们发现两个块要么有交点，要么没交点，并且只有横向块与纵向块相交，这完全符合二分图性质。</p>
<p>####BSOJ1775 xinyue 的约会</p>
<p>同上，但需要考虑有些边不需要添加。</p>
<p>####BSOJ2569 网络流 24 题 - 3 最小路径覆盖</p>
<p>把每个点拆成入点和出点，这样一个匹配就是一个边。在匹配中，每一个点的前驱和后继是唯一的，而只有起点不存在前驱，终点不存在后继。有多少个点没有前驱或后继，就有多少条路径。因此对于一个匹配，其路径数 = 点数 - 匹配数。</p>
<p>因此，最少路径 = 点数 - 最大匹配。</p>
<p>有关<strong>路径</strong>的问题可以将其拆成二分图，再观察路径的性质。</p>
<p>### 最小割</p>
<p>最小割的题目算是比较有价值，也是比较难转换的模型题目。</p>
<p>####POJ2125 Destroying the Graph</p>
<p>每条边可以被入点破坏也可以被出点破坏。因此构造二分图求最小割。</p>
<p>####POJ3469 Dual Core CPU</p>
<p>考虑没有额外代价的情况，则一个任务只能在两个 CPU 的其中一台运行。这个就是最小割模型，$S <span class="math inline">\(向任务 \)</span> i <span class="math inline">\(连边权为 \)</span> a_i<span class="math inline">\(的边，\)</span>i <span class="math inline">\(向 \)</span> T <span class="math inline">\(连边权为 \)</span> b_i<span class="math inline">\(的边，则最小割就把所有点集分成两个部分（要么属于 \)</span> S <span class="math inline">\(，要么属于 \)</span> T $），且使得所有割边代价最小。</p>
<p>考虑加上代价。我们希望当 $ a <span class="math inline">\(与 \)</span> b <span class="math inline">\(不在同一个点集时能有额外的权 \)</span> w _i<span class="math inline">\(，这很像最小割的定义，因此我们考虑把 \)</span>w_i<span class="math inline">\(也加入到最小割。具体做法是在 \)</span> a <span class="math inline">\(与 \)</span> b <span class="math inline">\(之间连边权为 \)</span> w_i<span class="math inline">\(的无向边，这样当 \)</span> a <span class="math inline">\(与 \)</span> b $ 在同一个集合时此边不会是割边，而不在同一个集合时，会把额外代价计算。这就解决了问题。</p>
<p>往往要从定义出发：割边是连接两个属于<strong>不同集合的点</strong>的边集。下面的题目也显示出这个特点。</p>
<p>####SPOJ839 Optimal Marks</p>
<p>我们发现因为存在位运算，所有边权的总和最小等价于边权的每一位总和最小。因此单独考虑每一位，且每一位都只有 $ 0$ 和 $1 $ 可以取。注意到 xor 的定义是<strong>两个数不同则为<span class="math inline"> \(1\)</span>，相同为<span class="math inline"> \(0\)</span></strong>，边权只有端点的两个数不同时才被计算，这和最小割的定义同样很像。</p>
<p>因此最小割模型显然。把两个集合当成选择的值，向每个点连接容量为<span class="math inline"> \(\infty\)</span> 的边，有边相连的两个点连容量为 $ 1 <span class="math inline">\(的边。这么做的目的是：割边只能在 ** 特定的边 ** 取到，而不能在 ** 容量为 **\)</span>$ 的边取到。对每一位跑一次最小割即可。</p>
<p>我们得到一个直观的感受：如果一条边不想成为割边，只需要把容量设为<span class="math inline"> \(\infty\)</span> 。</p>
<p>####ZJU2676 Network Wars</p>
<p>见论文。此处重点讨论细节。</p>
<p>对给定网络，我们需要选出一个最小割集。由于分数规划使得边权可能为负，而负边权相当于反边，是不会被计算在最小割的容量的，因此需要手动叠加，而只对边权 $ &gt; 0 $ 的边求割。</p>
<p>####BSOJ2550 网络流 24 题 - 9 方格取数问题</p>
<p>对棋盘黑白染色后发现相邻的不同颜色点之间只能选择其中一个。因此把有冲突的点连边，求最大独立集（权为<span class="math inline"> \(1\)</span> 的最大点权独立集）即可。注意是二分图，转化求最小点权覆盖集<span class="math inline"> \(\to\)</span> 最小割<span class="math inline"> \(\to\)</span> 最大流。</p>
<p>####CQOI2017 老 C 的方块</p>
<p>题目描述很复杂，大致就是在一个特殊的网格上不能有特定图形出现，而去除一个网格需要一定费用。</p>
<p>然后我们观察四个图，发现特殊边两侧刚好连接两个格子。“某些状态不能共存，而去掉某个状态需要一定代价” 的想法让我们想到最小割（虽然数据范围上不是这样的）。因此有这些形状的格子要连接起来，并且至少有一个连接源点或汇点。经过一番构图，我们构造出下面这种网络：</p>
<p><span class="math display">\[
\begin {matrix}
\vdots &amp; &amp;\vdots &amp; &amp;\vdots &amp; &amp;\vdots &amp; &amp;\vdots  &amp; &amp;\vdots\\
\downarrow &amp;\Leftarrow &amp;\leftarrow &amp;\leftarrow &amp;S &amp; &amp;T &amp;\leftarrow &amp;\leftarrow &amp;\Leftarrow &amp;\leftarrow &amp;\cdots\\
\downarrow &amp; &amp;\uparrow &amp;  &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow  &amp; &amp;\uparrow &amp;\\
T &amp; &amp;S &amp;\rightarrow &amp;\rightarrow &amp;\Rightarrow &amp;\rightarrow &amp;\rightarrow &amp;T &amp; &amp;S &amp;\cdots\\
\uparrow &amp;  &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow  &amp;\\
\uparrow &amp;\Leftarrow &amp;\leftarrow &amp;\leftarrow &amp;S &amp; &amp;T &amp;\leftarrow &amp;\leftarrow &amp;\Leftarrow &amp;\leftarrow &amp;\cdots\\
\downarrow &amp; &amp;\uparrow &amp;  &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow  &amp; &amp;\uparrow &amp;\\
T &amp; &amp;S &amp;\rightarrow &amp;\rightarrow &amp;\Rightarrow &amp;\rightarrow &amp;\rightarrow &amp;T &amp; &amp;S &amp;\cdots\\
\uparrow &amp;  &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow  &amp;\\
\uparrow &amp;\Leftarrow &amp;\leftarrow &amp;\leftarrow &amp;S &amp; &amp;T &amp;\leftarrow &amp;\leftarrow &amp;\Leftarrow &amp;\leftarrow &amp;\cdots
\end {matrix}
\\
\text {（有没有想到洋流图）}
\]</span></p>
<p>每个交点是原图中的一个方块，双线箭头代表图中的特殊边。我们在这张网络图上能发现原图中的四种方块都对应一条从<span class="math inline"> \(S\)</span> 到<span class="math inline"> \(T\)</span> 的边，我们只需要求最小割就是最小花费。问题是怎么设置边权。</p>
<p>明显处于<span class="math inline"> \(S\)</span> 和<span class="math inline"> \(T\)</span> 上的点应该各自连<span class="math inline"> \(w\)</span> 到<span class="math inline"> \(S\)</span> 或<span class="math inline"> \(T\)</span>，那特殊边两侧的两个方块呢？如果要删掉一个方块，则只需要删掉一个就好了，两个同时删是不划算的。因此我们只需要给特殊边设两个方块的较小<span class="math inline"> \(w\)</span> 即可。</p>
<p>虽然本题点的规模达到了<span class="math inline"> \(10^5\)</span>，但棋盘很大，连边只在相邻的方块出现，因此边数不大。跑跑最大流就过了。</p>
<p>是道建图好题。我们可以得到一个直观感受：最小割可以解决不共存的最小代价问题。这跟上面利用割的定义最小化分点代价不同，其出发点是<strong>源汇点的联通性</strong>。</p>
<p>### 最大权闭合图</p>
<p>####BSOJ2543 网络流 24 题 - 2 太空飞行计划</p>
<p>很明显的最大权闭合图模型，直接转化。</p>
<p>####NOI2006 最大获利</p>
<p>见论文。选定一个边同时要选定两个点，转化模型。</p>
<p>####TJOI2015 线性代数</p>
<p>转化题目后发现相当于有许多物品，要得到物品 $ i <span class="math inline">\(和 \)</span> j <span class="math inline">\(需要先选定 \)</span> i <span class="math inline">\(和 \)</span> j<span class="math inline">\(，而选定 \)</span> i <span class="math inline">\(和 \)</span> j$ 都需要代价。接着就可以做了。</p>
<p>有个神奇的做法是暴力寻找不要什么物品，时间复杂度 $ (n ^ 3 n)$，跑起来还挺快。</p>
<p>### 费用流</p>
<p>####BSOJ4914 疯狂的方格取数</p>
<p>拆点。由于网络流与边有关，因此和点有关的题目往往需要把点拆掉来建立边。</p>
<p>####ZJOI2010 网络扩容</p>
<p>第一个最大流很简单。</p>
<p>第二个我一开始估计是在残余网络上操作，然后跑个 DP 计算每条路径扩展 k 所需要的费用，再统计和即可。不过这不好实现还容易 TLE。发现所需费用是费用流的表达式，但是如果直接跑费用流，我们希望有容量的边不计算权值，没流量的边计算权值，怎么办？</p>
<p>残余网络中，原图都加一条边权为<span class="math inline"> \(w\)</span>，容量为<span class="math inline"> \(\infty\)</span> 的边。再从超级源点<span class="math inline"> \(s\)</span> 向<span class="math inline"> \(1\)</span> 建边权为<span class="math inline"> \(0\)</span>，容量为<span class="math inline"> \(det\)</span> 的边。这样，在跑费用流的时候，如果一个边有流量就会优先选择这条没有花费的边，否则只能选择有花费的新边。</p>
<p>这个思路挺巧妙的，虽然我觉得对<span class="math inline"> \(n=1000,m=5000\)</span> 的数据跑<span class="math inline"> \(\mathrm{O}(n^2m)\)</span> 有点夸张。不过据说 Dinic 的复杂度和 SPFA 一样是个迷，因此还是可以跑的。</p>
<p>####SCOI2007 修车</p>
<p>本质上是一个打水问题，不过在不同的维修队列里花费时间也不一样。</p>
<p>费用流模型不难想到，可是具有后效性。然而我们发现把每个维修人员的</p>
<p>【未完成】</p>
<p>####NOI2008 志愿者招募</p>
<p>题目太神，不会做。但是还是放上 <a target="_blank" rel="noopener" href="https://www.byvoid.com/zhs/blog/noi-2008-employee">BYV 的题解</a>。</p>
<p>具体的思路是把不等式添加变量修改为等式，这样容易思考。其次发现每个人都从某段时间开始，某段时间结束，可以考虑到差分。两者结合就得到了新的等式，并且由于差分的特性，每个有关变量都刚好出现两次且符号相反。</p>
<p>啧啧称奇。（虽然我不知道为什么推出来之后，需要求最大流。）</p>
<p>## 总结</p>
<p>网络流通常用来求一类有限制（选择次数、不可同选）的题目。建模相比起算法往往更重要，因此如何构造网络是网络流题目的一个重点。</p>
<ul>
<li>需要掌握图的<strong>点与边集</strong>关系，尤其是二分图
<ul>
<li>最大匹配数<span class="math inline"> \(+\)</span> 最小边覆盖数<span class="math inline"> \(=\)</span> 顶点数（条件：联通图）</li>
<li>最大独立集<span class="math inline"> \(+\)</span> 最小点覆盖数<span class="math inline"> \(=\)</span> 顶点数</li>
<li> König 定理：最大匹配数<span class="math inline"> \(=\)</span> 最小点覆盖（条件：二分图）</li>
<li>最大流<span class="math inline"> \(=\)</span> 最小割</li>
<li>最小割<span class="math inline"> \(=\)</span> 最小点权覆盖集（条件：二分图）</li>
<li>最小点权覆盖集数<span class="math inline"> \(+\)</span> 最大点权独立集数<span class="math inline"> \(=\)</span> 顶点数（条件：二分图）</li>
</ul></li>
<li>网络流的建模入手点
<ul>
<li>有关选择的<strong>依赖关系</strong>的问题，可以考虑最大权闭合图</li>
<li>有关<strong>路径</strong>的问题可以按照出边入边将其拆成二分图，再观察路径的性质</li>
<li>有关<strong>等式</strong>或<strong>不等式</strong>，考虑流量平衡（如上下界网络流、志愿者招募）</li>
<li>有关<strong>不共存的最小代价</strong>，考虑最小割使源汇不联通的性质，在不共存状态间连边，再与源汇连边求最小割</li>
</ul></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/summary/number-theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar_tozuka_kotaro.jpg">
      <meta itemprop="name" content="nikkukun">
      <meta itemprop="description" content="是个蒟蒻，梦想不是造飞机。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nikkukun's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/summary/number-theory/" class="post-title-link" itemprop="url">数论总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-14T00:00:00+00:00">2017-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-12 14:16:05" itemprop="dateModified" datetime="2021-06-12T14:16:05+00:00">2021-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">算法总结</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>东西很分散，知识比较乱，因此就放在一起写了。</p>
<!---more--->
<h1 id="素性判断">素性判断</h1>
<h2 id="rabin-miller">Rabin-Miller</h2>
<p>单次时间复杂度为<span class="math inline"> \(\mathrm{O}(\log n)\)</span> 的判素方法。当底数枚举范围为<span class="math inline"> \((1,p]\)</span> 时，正确概率为<span class="math inline"> \(1-\left(1/4\right)^p\)</span>。OI 中一般测试 4~5 次就足够了。原理是利用了费马小定理，具体的探究见 Matrix67 的<a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/234"><em>素数与素性测试</em></a>。</p>
<ol type="1">
<li>将待测试数<span class="math inline"> \(x\)</span> 化为<span class="math inline"> \(x-1=a*2^p\)</span> 的形式；</li>
<li>选择一个<span class="math inline"> \([2.n)\)</span> 间的底数<span class="math inline"> \(bas\)</span>，对每个底数<span class="math inline"> \(bas\)</span> 考察：
<ol type="1">
<li>计算<span class="math inline"> \(x'=bas^{a*2^p}\bmod{x}\)</span>；</li>
<li>分类讨论：
<ul>
<li><span class="math inline">\(x'=1\)</span>。令<span class="math inline"> \(p'=\frac p2\)</span>，继续考察<span class="math inline"> \(bas^{a*2^{p'}}\pmod{x}\)</span>；</li>
<li><span class="math inline">\(x'=x-1\)</span>。则<span class="math inline"> \(x\)</span> 为<span class="math inline"> \(bas\)</span> 下的伪素数，考察下一个底数；</li>
<li>否则<span class="math inline"> \(x\)</span> 为合数，退出算法。</li>
</ul></li>
</ol></li>
</ol>
<p>附上代码。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RabinMiller</span><span class="params">(ll n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>||!(n&amp;<span class="number">1</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;ll a;</span><br><span class="line">    <span class="keyword">while</span>((n<span class="number">-1</span>)%(<span class="number">1</span>&lt;&lt;(p+<span class="number">1</span>))==<span class="number">0</span>)p++;</span><br><span class="line">    a=(n<span class="number">-1</span>)/(<span class="number">1</span>&lt;&lt;p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=UPP;i++){       <span class="comment">//UPP为测试次数</span></span><br><span class="line">        <span class="keyword">int</span> bas=rand()%(n<span class="number">-2</span>)+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=p;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">            ll tmp=QPow(bas,a*((ll)<span class="number">1</span>&lt;&lt;j),n);</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>实际运用中还是很快的。</p>
<h2 id="eratosthenes筛法">Eratosthenes 筛法</h2>
<p>NOIP 知识点。直接放代码。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eratosthenes</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> upp=<span class="built_in">sqrt</span>(N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=upp;++i)        <span class="comment">//大于sqrt(N)的数已经被筛过了</span></span><br><span class="line">        <span class="keyword">if</span>(!notPri[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i*i;j&lt;N;j+=i)      <span class="comment">//小于i^2的数已经被筛过了</span></span><br><span class="line">                notPri[j]=<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>值得注意的是我不止一次没注意筛法的上下界，使得复杂度变大。（其实也没有多慢）</p>
<h2 id="线筛">线筛</h2>
<h1 id="欧拉函数">欧拉函数</h1>
<p>欧拉函数<span class="math inline"> \(\Phi\)</span> 是积性函数，因此可以线性筛。</p>
<p>代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Phi</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)phi[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">        <span class="keyword">if</span>(phi[i]==i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j+=i)</span><br><span class="line">                phi[j]-=phi[j]/i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>单个<span class="math inline"> \(\Phi\)</span> 值只需要利用<span class="math inline"> \(\Phi(n)=\Pi_{i=1}(1- \frac 1{p_i})\)</span> 即可。注意需要特判大于<span class="math inline"> \(\sqrt{n}\)</span> 的因子。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Phi</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ret=x，upp=<span class="keyword">int</span>(<span class="built_in">sqrt</span>(x)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=upp;++i)</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>){</span><br><span class="line">            ret-=ret/i;</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>)x/=i;</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>)ret-=ret/x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="欧拉函数的一些性质">欧拉函数的一些性质</h2>
<p>由辗转相除法可以得：</p>
<p><span class="math display">\[(a,b)=(a,a+b)=(b,a+b)\]</span></p>
<p><span class="math inline">\(\varphi (n)\)</span> 求的是<span class="math inline"> \([1,n]\)</span> 中<span class="math inline"> \((i,n)=1\)</span> 的个数，若<span class="math inline"> \((i,n)=1\)</span>，则<span class="math inline"> \((n-i,i)=1\)</span>，即互质的数是成对存在的。因此<span class="math inline"> \([1,n] (n&gt;1)\)</span> 中与<span class="math inline"> \(2n\)</span> 互质的数有<span class="math inline"> \(\varphi (n)/2\)</span> 个。</p>
<p>由上述结论容易得到：</p>
<p><span class="math display">\[ \sum _{i=1,\ (i,n)=1}^n = \frac {n\times \varphi(i)}2 \quad (n&gt;1)\]</span></p>
<p>一些内容可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37067555">关于欧拉函数及其一些性质的美妙证明（2）</a>。</p>
<h2 id="指数循环节">指数循环节</h2>
<p>考虑这么个式子：<span class="math inline">\(a^x\equiv c\pmod{p}\)</span>。如果<span class="math inline"> \(x\)</span> 很大就不能直接求了。</p>
<p>明显<span class="math inline"> \(p\)</span> 为质数时，根据费马小定理有：</p>
<p><span class="math display">\[
a^x \bmod{p} = a^{x \bmod \phi(p)} \bmod{p}
\]</span></p>
<p>然而<span class="math inline"> \(p\)</span> 是合数也有结论：</p>
<p><span class="math display">\[
a^x \bmod{p} = a^{x \bmod \phi(p)+\phi(p)} \bmod{p}\quad (x\geq\phi(p))
\]</span></p>
<p>注意有条件，不能直接用（虽然通常可以）。</p>
<h2 id="原根">原根</h2>
<p>待补</p>
<h2 id="欧拉定理">欧拉定理</h2>
<p>待补</p>
<h2 id="扩展欧拉定理">扩展欧拉定理</h2>
<p>待补，但是其实上面给出式子了。</p>
<h1 id="离散变换">离散变换</h1>
<p>和模运算有关。模运算除了除法外，四则运算都可以先模再运算最后模。除法需要找逆元。</p>
<h2 id="逆元">逆元</h2>
<p><span class="math inline">\(x\)</span> 在<span class="math inline"> \(p\)</span> 下存在逆元的充分必要条件是<span class="math inline"> \((x,p)=1\)</span>。</p>
<p>逆元的求法：</p>
<ul>
<li>扩展欧几里得（求解<span class="math inline"> \(a*inv+p*y=1\)</span>）</li>
<li>费马小定理（<span class="math inline">\(a^{\Phi (p)}\equiv 1\pmod {p} \Rightarrow inv=a^{p-2}\ \text {（p 为素数）}\)</span>）</li>
<li>线性递推逆元表（<span class="math inline">\(inv_i=\left(p-\lfloor \frac pi \rfloor \right)* inv_{p\bmod{i}}\bmod{p}\)</span>）</li>
</ul>
<p>第三个很玄学就是了。简单证明帮助理解：</p>
<p>令<span class="math inline"> \(p=nt+k\)</span>，则：</p>
<p><span class="math display">\[
\begin{aligned}
nt+k&amp;\equiv 0\pmod{p} \\
\Rightarrow k&amp;\equiv -nt\pmod{p} \\
\Rightarrow n^{-1}&amp;\equiv -tk^{-1}\pmod{p} \\
\Rightarrow n^{-1}&amp;\equiv -\lfloor{\frac pn}\rfloor *(p\bmod{n})^{-1}\pmod{p}
\end{aligned}
\]</span></p>
<p>即<span class="math inline"> \(inv_i=\left(p-\lfloor \frac pi \rfloor \right)* inv_{p\bmod{i}}\bmod{p}\)</span>。</p>
<p>但是这个东西有点难背。我们是不是可以<span class="math inline"> \(\mathcal{O}(n)\)</span> 求阶乘，可以<span class="math inline"> \(\mathcal{O}(\log n)\)</span> 求<span class="math inline"> \((n!)^{-1}\)</span>，可以<span class="math inline"> \(\mathcal{O}(1)\)</span> 求<span class="math inline"> \(n^{-1} = (n-1)!/n!\)</span> 呢？</p>
<p>好了，现在我们找到一个<span class="math inline"> \(\mathcal{O}(n + \log n)\)</span> 求<span class="math inline"> \([1,n]\)</span> 逆元的方法了。</p>
<h2 id="离散对数">离散对数</h2>
<p>其实就是求解<span class="math inline"> \(a^x\equiv b \pmod{p}\)</span>。根据费马小定理，对于<span class="math inline"> \(p\)</span> 为质数的情况，<span class="math inline">\(i\)</span> 取<span class="math inline"> \([0,p)\)</span> 时恰好使得<span class="math inline"> \(a^i\bmod{p}\)</span> 取到<span class="math inline"> \([0,p)\)</span> 的值各一次。因此此方程若有解，则一定在<span class="math inline"> \([0,p)\)</span> 内有且仅有一解。</p>
<h3 id="baby-step-giant-step">Baby-step Giant-step</h3>
<p>求解这个方程的大步小步算法（Baby-step Giant-step）可以参考<em>训练指南</em>。这里只描述框架。</p>
<ol type="1">
<li>令<span class="math inline"> \(m=\sqrt{p}\)</span>，用哈希表或 map 记录取得<span class="math inline"> \(a^i\bmod{p}\ (0\leq i&lt;m)\)</span> 时<span class="math inline"> \(i\)</span> 的最小值；</li>
<li>对<span class="math inline"> \(a^{j \times m}\ (1\leq j\leq m)\)</span> 查找表中是否存在<span class="math inline"> \(b*a^{-m}\bmod{p}\)</span> 对应的<span class="math inline"> \(i\)</span> 值：
<ul>
<li>存在。则最小解为<span class="math inline"> \(x=j*m+i\)</span>；</li>
<li>不存在。考察下一个 j。</li>
</ul></li>
</ol>
<p>时间复杂度为<span class="math inline"> \(\mathrm{O}(\sqrt{n})\)</span>。然而使用 BSGS 的前提条件是<span class="math inline"> \((a,p)=1\)</span>，当<span class="math inline"> \(p\)</span> 不是质数的时候不一定能使用（但是<span class="math inline"> \(p\)</span> 为质数时必须有<span class="math inline"> \(a&lt;p\)</span>，否则也不保证<span class="math inline"> \(a\)</span> 不为<span class="math inline"> \(p\)</span> 的倍数）。好在我们可以使用扩展 BSGS 来解决<span class="math inline"> \(p\)</span> 不是质数的情况。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(ll a,ll b,ll p)</span></span>{</span><br><span class="line">    <span class="built_in">map</span>&lt;ll,<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> m=(<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">    ll tmp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++,tmp=tmp*a%p)</span><br><span class="line">        <span class="keyword">if</span>(!s.count(tmp))s[tmp]=i;</span><br><span class="line">    ll inv=Invert(tmp,p);tmp=b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++,tmp=tmp*inv%p)</span><br><span class="line">        <span class="keyword">if</span>(s.count(tmp))<span class="keyword">return</span> i*m+s[tmp]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="扩展baby-step-giant-step">扩展 Baby-step Giant-step</h3>
<p>我们不能求解的原因是费马定理不一定再适用，但可以通过不断对<span class="math inline"> \(a\)</span> 和<span class="math inline"> \(p\)</span> 提取 GCD 的方法使得<span class="math inline"> \((a,p)=1\)</span>，再应用 BSGS。</p>
<p>明确这么一件事：令<span class="math inline"> \(g=(a,p)\)</span>，则<span class="math inline"> \(a^x\equiv b\ \pmod{p} \Leftrightarrow \frac ag \times a^{x-1}\equiv \frac bg \pmod{\frac pg}\)</span>，具体理由可以展开为不定方程后同除<span class="math inline"> \(g\)</span> 即可。这样就可以通过不断除<span class="math inline"> \((a,p)\)</span> 使得<span class="math inline"> \((a,p)=1\)</span>。流程：</p>
<ol type="1">
<li>当<span class="math inline"> \(g=(a,p)\not =1\)</span>，化方程为<span class="math inline"> \((\frac ag) \times a^{x-1}\equiv \frac bg\ \pmod{\frac pg} \Rightarrow a^{x-1}\equiv \frac bg \times (\frac ag)^{-1}\ \pmod{\frac pg}\)</span>；
<ul>
<li>若<span class="math inline"> \(b\)</span> 已经为<span class="math inline"> \(1\)</span>，则<span class="math inline"> \(x\)</span> 为除以<span class="math inline"> \(g\)</span> 的次数（特判）；</li>
<li>否则操作直到<span class="math inline"> \((a,p)=1\)</span>；</li>
</ul></li>
<li>使用 BSGS。</li>
</ol>
<p>注意特判是需要的，因为当<span class="math inline"> \((a,p)\not =1\)</span> 时也有可能存在解<span class="math inline"> \(x\)</span>，而继续操作会使得<span class="math inline"> \(x\)</span> 增大。</p>
<h2 id="同余方程">同余方程</h2>
<p>即求解<span class="math inline"> \(ax+by=c\)</span>，也可以转化为<span class="math inline"> \(ax\equiv c\ \pmod{b}\)</span>。</p>
<h3 id="扩展欧几里得">扩展欧几里得</h3>
<p>求解方法是扩展欧几里得，有解的充分必要条件是<span class="math inline"> \((a,b)|c\)</span>，求解的结果<span class="math inline"> \(x_0,y_0\)</span> 是最小化<span class="math inline"> \(|x|+|y|\)</span> 的一组解。由于比较模板，就直接放上代码了。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExtendGCD</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> &amp;g)</span>       <span class="comment">//x和y都是传引用</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(!b)x=<span class="number">1</span>,y=<span class="number">0</span>,g=a;</span><br><span class="line">    <span class="keyword">else</span> ExtendGCD(b,a%b,y,x,g),y-=x*(a/b);      <span class="comment">//x和y要交换，a/b必须要向下取整</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>时间复杂度和欧几里得一样，可以近似看作<span class="math inline"> \(\mathrm{O}(\log{n})\)</span>。</p>
<p>求解的是<span class="math inline"> \(ax+by=(a,b)\)</span> 的解。以下我们对变量带上<span class="math inline"> \('\)</span> 符号时表示该值为原值除以<span class="math inline"> \(g\)</span>，则明显原问题的解为<span class="math inline"> \(x=x_0 \times c',y=y_0 \times c'\)</span>。</p>
<p>要求出其他的解，则只需要迭代<span class="math inline"> \(x=x_0+b',y=y_0-a'\)</span> 即可。这个结论可以通过假设一组其他解<span class="math inline"> \(x,y\)</span> 和<span class="math inline"> \(x_0,y_0\)</span> 联立解得。我们往往要求<span class="math inline"> \(x\)</span> 的最小非负解，根据这个结论我们可以得到<span class="math inline"> \(x_+=(x_0\bmod{b'}+b')\bmod{b'c'}\)</span>。</p>
<h3 id="欧几里得">欧几里得</h3>
<p>由辗转相除法可以得：</p>
<p><span class="math display">\[(a,b)=(a,a+b)=(b,a+b)\]</span></p>
<p>这个结论我也不知道有什么用，但是看起来可以化简一类<strong>累和 GCD</strong> 的问题。如 <em>SDOI2008 沙拉公主的困惑</em> 处理了<span class="math inline"> \((M! , i) = (M! + i , i) \ (1&lt;i \leq M!)\)</span>，使得一个大数<span class="math inline"> \(N!\ (N&gt;M)\)</span> 可以被分解成多段长度为<span class="math inline"> \(M!\)</span> 的段，从而降低了求<span class="math inline"> \(N!\)</span> 与<span class="math inline"> \(M!\)</span> 中互质的二元组数的困难。</p>
<p>另一个例子见<a href="/spring-training/spring-training-190705">这场比赛的 I 题</a>。</p>
<h3 id="类欧几里得">类欧几里得</h3>
<p>震惊了，还有这种算法。等省选结束学习一发。</p>
<h2 id="中国剩余定理">中国剩余定理</h2>
<p>对于单组同余方程<span class="math inline"> \(ax\equiv c\pmod{p}\)</span> 求解，我们可以使用扩展欧几里得。但对于多组同余方程<span class="math inline"> \(x\equiv c_i\pmod{p_i}\)</span>，我们需要中国剩余定理（Chinese Remainder Theorem）。</p>
<p>假设有<span class="math inline"> \(n\)</span> 个方程组，且<span class="math inline"> \(M=\prod p_i,m_i=\frac M{p_i}\)</span>。我们考虑其中的一个方程<span class="math inline"> \(x\equiv c_i\pmod{p_i}\)</span>。由于<span class="math inline"> \((m_i,p_i)=1\)</span>，因此方程<span class="math inline"> \(m_ix+p_iy=1\)</span> 有解。我们对这个方程两边同模<span class="math inline"> \(p_i\)</span>，并且令<span class="math inline"> \(e_i=m_ix\)</span>，则有<span class="math inline"> \(e_i\equiv 1\pmod{p_i}\)</span>。</p>
<p>根据一些神奇的方法构造出一个解<span class="math inline"> \(x=\sum_{i=1}^n c_ie_i\)</span>。观察这个式子，我们给两边同除<span class="math inline"> \(p_i\)</span>，则只剩下<span class="math inline"> \(x\equiv c_ie_i \equiv c_i\pmod{p_i}\)</span>，即原模方程组。然后就可以通过扩展欧几里得得到<span class="math inline"> \(x\)</span> 的一个解了。</p>
<h3 id="扩展中国剩余定理">扩展中国剩余定理</h3>
<p>用于解决不互质的情况。</p>
<p>假设任意两个方程组<span class="math inline"> \(x\equiv c_1\pmod{p_1},x\equiv c_2\pmod{p_2}\)</span>，化为方程组：</p>
<p><span class="math display">\[
\begin{cases}
x=c_1+k_1p_1 \\
x=c_2+k_2p_2 \\
\end{cases}
\]</span></p>
<p>联立得<span class="math inline"> \(c_1+k_1p_1=c_2+k_2p_2\)</span>，可以解不定方程得到<span class="math inline"> \(k_1,k_2\)</span> 的一组解<span class="math inline"> \(k_1',k_2'\)</span>，因此<span class="math inline"> \(k_1=k_1'\frac{a_2-a_1}g+T\frac {p_2}g\)</span>，<span class="math inline">\(T\)</span> 为任意整数。回代入任意一个<span class="math inline"> \(x\)</span> 的方程得：</p>
<p><span class="math display">\[
\begin{aligned}
x=&amp;c_1+p_1k_1 \\
=&amp;c_1+p_1(k_1'\frac{a_2-a_1}g+T\frac {p_2}g) \\
=&amp;c_1+p_1k_1'(\frac{a_2-a_1}g+T\frac {p_1p_2}g)
\end{aligned}
\]</span></p>
<p>即 $xc_1+p_1k_1'g  <span class="math inline">\(，两个方程组合并为一个方程组。需要合并最多 \)</span>n-1<span class="math inline">\(个方程组，时间复杂度 \)</span>(n)<span class="math inline">\(。注意 \)</span>x$ 可能会很大，一般化为最小非负解再计算。</p>
<p>用这个方法也可以推出非扩展情况，然而非扩展情况的形式推不出扩展情况。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">ExtendCRT</span><span class="params">()</span></span>{</span><br><span class="line">    ll a0,p0,a1,p1;<span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;p0&gt;&gt;a0;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line">        ll x,y,g,c;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p1&gt;&gt;a1;</span><br><span class="line">        <span class="keyword">if</span>(flag){</span><br><span class="line">            ExtendGCD(p0,p1,x,y,g);</span><br><span class="line">            c=a1-a0;</span><br><span class="line">            <span class="keyword">if</span>(c%g){flag=<span class="number">0</span>;<span class="keyword">continue</span>;}</span><br><span class="line">            x=x*(c/g)%(p1/g);</span><br><span class="line">            a0+=x*p0;p0=p0*p1/g;</span><br><span class="line">            a0%=p0;		<span class="comment">//防止溢出</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(flag)<span class="keyword">return</span> (a0%p0+p0)%p0;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个代码可能是有问题的，在 POJ 过了，在 BSOJ 没过。<del>然后我小叮当今天就要打爆你 CRT 的头</del></p>
<h1 id="神奇小技巧">神奇小技巧</h1>
<h2 id="快速幂">快速幂</h2>
<p>NOIP 内容。时间复杂度<span class="math inline"> \(\mathrm{O}(\log{n})\)</span>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">QPow</span><span class="params">(ll bas,ll t)</span></span>{</span><br><span class="line">    ll ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;t;t&gt;&gt;=<span class="number">1</span>,bas=QMul(bas,bas))</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>)ret=QMul(ret,bas);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="快速乘">快速乘</h2>
<p>这个就比较少见了。当两个数的乘法（取模）可能连 long long 都爆时，就可以用这个方法。其思想是将十进制乘法变为二进制乘法，并按位计算。由于乘数<span class="math inline"> \(b\)</span> 每次只会翻倍，因此不会超出 long long。时间复杂度<span class="math inline"> \(\mathrm{O}(\log{n})\)</span>。</p>
<pre><code>ll QMul(ll a,ll b){
    if(a&gt;b)swap(a,b);
    ll ret=0;
    for(;b;b&gt;&gt;=1,(a&lt;&lt;=1)%=p)
        if(b&amp;1)(ret+=a)%=p;
    return ret;
}</code></pre>
<h1 id="练习">练习</h1>
<p>数论题目真是多而难写。很绝望。有些基础题真的水水的，就不放了。</p>
<h2 id="baby-step-giant-step-1">Baby-step Giant-step</h2>
<h3 id="sdoi2011-计算器">SDOI2011 计算器</h3>
<p>操作 1 为快速幂，操作 2 为同余方程，操作 3 为离散对数。</p>
<h3 id="sdoi2013-随机数生成器">SDOI2013 随机数生成器</h3>
<p>通过对递推式进行迭代可以得到离散对数的方程，需要扩展 BSGS。但是题目需要多个分类讨论，比较复杂。</p>
<h2 id="同余方程-1">同余方程</h2>
<h3 id="noi2002-荒岛野人">NOI2002 荒岛野人</h3>
<p>假设<span class="math inline"> \(M\)</span> 个洞穴两个野人<span class="math inline"> \(t\)</span> 天相遇，则有<span class="math inline"> \(pos_i+t \times det_i=pos_j+t \times det_j \pmod{M}\)</span>，可以解不定方程。如果不相遇，则<span class="math inline"> \(t\)</span> 应该大于两个野人寿命最小的那个，或者根本无解。</p>
<p>从小到大枚举<span class="math inline"> \(M\)</span>，对每个<span class="math inline"> \(M\)</span> 对任意两个野人判定是否可行即可。时间复杂度<span class="math inline"> \(\mathrm{O}(MN^2)\)</span>，事实上到不了上界。</p>
<h2 id="欧拉函数-1">欧拉函数</h2>
<h3 id="sdoi2008-沙拉公主的困惑">SDOI2008 沙拉公主的困惑</h3>
<p>由于辗转相除法<span class="math inline"> \((a+b,b)=(a,b)\)</span>，因此<span class="math inline"> \((M!,i)=(M!+i,i)\)</span>，即对于<span class="math inline"> \([1,N!]\)</span> 的每一段<span class="math inline"> \(M!\)</span>，与<span class="math inline"> \(M!\)</span> 互质的个数都是一样的。我们知道与<span class="math inline"> \(M!\)</span> 互质的个数为<span class="math inline"> \(\phi(M!)\)</span>，因此答案<span class="math inline"> \(ans={N!*\phi(M!) \over M!}\)</span>。</p>
<p>展开欧拉函数得：</p>
<p><span class="math display">\[ans=N!*\Pi_{i=1} (1-\frac1 {p_i}) \quad (p_i|M!\text {且} p_i\text {为质数})\]</span></p>
<p>不难发现<span class="math inline"> \(p_i\)</span> 其实就是<span class="math inline"> \([1,m]\)</span> 的所有质数，因此我们可以预处理出小于<span class="math inline"> \(n\)</span> 的质数的<span class="math inline"> \((i-1)\over i\)</span> 的积和<span class="math inline"> \(n!\)</span>，就可以<span class="math inline"> \(\mathrm{O}(1)\)</span> 回答询问了。</p>
<p>总时间复杂度<span class="math inline"> \(\mathrm{O}(max(n,m))\)</span>。</p>
<h2 id="快速乘快速幂">快速乘 / 快速幂</h2>
<h3 id="bzoj4766-文艺计算姬">BZOJ4766 文艺计算姬</h3>
<p>根据矩阵树定理可以推得答案为<span class="math inline"> \(n^{m-1}*m^{n-1}\)</span>，需要快速乘和快速幂。</p>
<p>也可以用 prufer 序列得到。</p>
<h1 id="总结">总结</h1>
<p>数论是很神奇的东西，数论题是奥妙重重的题目。入手点一般在于将题目抽象为目标式、将目标式化简为高效可求式的过程。为此必须熟练掌握初等数论的内容<del>特别是结论</del>，以应对其中的数学变换。</p>
<p>当然猜测不出规律的时候可以打表观测<del>说不定就猜对了</del>。</p>
<p>（然后没有具体的总结，毕竟数论变化太多，需要结合题目看）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nikkukun"
      src="/images/avatar_tozuka_kotaro.jpg">
  <p class="site-author-name" itemprop="name">nikkukun</p>
  <div class="site-description" itemprop="description">是个蒟蒻，梦想不是造飞机。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:tyakennikku@163.com" title="E-Mail → mailto:tyakennikku@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1113119882&website=www.oicqzone.com" title="QQ → tencent:&#x2F;&#x2F;AddContact&#x2F;?fromId&#x3D;45&amp;fromSubId&#x3D;1&amp;subcmd&#x3D;all&amp;uin&#x3D;1113119882&amp;website&#x3D;www.oicqzone.com" rel="noopener" target="_blank"><i class="fa fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/SaltedHXJ/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;SaltedHXJ&#x2F;" rel="noopener" target="_blank">_ConveX</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://potassiumwings.github.io/" title="https:&#x2F;&#x2F;potassiumwings.github.io&#x2F;" rel="noopener" target="_blank">Potassium</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nikkukun</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script type="text/javascript" src="/js/fold_action.js"></script>
</body>
</html>
