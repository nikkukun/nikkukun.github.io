<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codechef November Lunchtime 2018]]></title>
    <url>%2Fcodechef%2Fnov-lunchtime-2018%2F</url>
    <content type="text"><![CDATA[比赛链接 Event 题解 水题，直接判断是否在模7意义下存在一个数\(t\)，使得\(t_{st}\leq t\leq t_{ed}\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;cstring&gt;using namespace std;const int N=100+5;map&lt;string,int&gt; idx;int v[N];int main()&#123; ios::sync_with_stdio(0); idx["monday"]=1; idx["tuesday"]=2; idx["wednesday"]=3; idx["thursday"]=4; idx["friday"]=5; idx["saturday"]=6; idx["sunday"]=7; int t;cin&gt;&gt;t; while(t--)&#123; string a,b;cin&gt;&gt;a&gt;&gt;b; int l,r;cin&gt;&gt;l&gt;&gt;r; int det=(idx[b]-idx[a]+7)%7+1; memset(v,0,sizeof(v)); for(int i=det;i&lt;N;i+=7)v[i]=1; int cnt=0; for(int i=l;i&lt;=r;i++) if(v[i])cnt++; if(cnt==0)cout&lt;&lt;"impossible\n"; else if(cnt&gt;1)cout&lt;&lt;"many\n"; else for(int i=l;i&lt;=r;i++) if(v[i])cout&lt;&lt;i&lt;&lt;endl; &#125; return 0;&#125; Beats and Pieces 题解 暴力模拟即可。 next_permutation()和reverse()真好用（逃） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=10+5;int a[N],b[N],c[N],l[N],r[N];int per[N];int n,m;int Factor(int x)&#123; return x?x*Factor(x-1):1;&#125;int GCD(int a,int b)&#123; return b?GCD(b,a%b):a;&#125;int main()&#123; ios::sync_with_stdio(0); int nCase;cin&gt;&gt;nCase; while(nCase--)&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; b[i]=a[i]; &#125; for(int i=1;i&lt;=m;i++)cin&gt;&gt;l[i]&gt;&gt;r[i]; for(int i=1;i&lt;=m;i++) reverse(b+l[i],b+r[i]+1); for(int i=1;i&lt;=n;i++)per[i]=i; int fac=Factor(n); int ans=0; for(int i=1;i&lt;=fac;i++)&#123; for(int j=1;j&lt;=n;j++)c[j]=a[j]; for(int j=1;j&lt;=m;j++) reverse(c+l[per[j]],c+r[per[j]]+1); bool flag=1; for(int j=1;j&lt;=n;j++) if(b[j]!=c[j])flag=0; ans+=flag; next_permutation(per+1,per+n+1); &#125; int g=GCD(ans,fac); cout&lt;&lt;ans/g&lt;&lt;'/'&lt;&lt;fac/g&lt;&lt;endl; &#125; return 0;&#125; Useful Number 题解 不妨设一个有用的数列的质数集合\(S=\{p_i|p_i是质数\}\)，那么对满足\(S\)的\(A_S\)中，所有\(a_i\in A_S\)都有因子\(p=\prod_{p_i \in S} p_i\)。 于是可以直接统计每个数的所有因子及其质因子个数，最后对所有出现的因子统计一下它的质因子个数\(\times\)含有这个数作为因子的\(a_i\)个数。 注意到每个数的因子个数不会超过\(\mathrm{O}(\log n)\)级别（这个是不是可以证明一下？），所以总时间复杂度是\(\mathrm{O}(n\log n)\)的。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int N=100000+5;bool notPri[N];int pri[N];void Euler()&#123; for(int i=2;i&lt;N;i++)&#123; if(!notPri[i])pri[++pri[0]]=i; for(int j=1;j&lt;=pri[0]&amp;&amp;i*pri[j]&lt;N;j++)&#123; notPri[i*pri[j]]=1; if(i%pri[j]==0)break; &#125; &#125;&#125;int fac[N],nfac[N];int cnt[N];void DFS(int v,int dep,int _nfac)&#123; if(dep&gt;fac[0])&#123; if(v&gt;1)cnt[v]++,nfac[v]=_nfac; return; &#125; DFS(v,dep+1,_nfac); DFS(v*fac[dep],dep+1,_nfac+1);&#125;int main()&#123; ios::sync_with_stdio(0); Euler(); int nCase;cin&gt;&gt;nCase; while(nCase--)&#123; memset(cnt,0,sizeof(cnt)); int n;cin&gt;&gt;n; for(int i=1,a;i&lt;=n;i++)&#123; cin&gt;&gt;a;fac[0]=0; for(int j=1;j&lt;=pri[0]&amp;&amp;pri[j]*pri[j]&lt;=a;j++) if(a%pri[j]==0)&#123; fac[++fac[0]]=pri[j]; while(a%pri[j]==0)a/=pri[j]; &#125; if(a&gt;1)fac[++fac[0]]=a; DFS(1,1,0); &#125; ll ans=0; for(int i=1;i&lt;N;i++) ans=max(ans,1LL*nfac[i]*cnt[i]); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Probability 题解 ZJOI2004 沼泽鳄鱼的进阶版本。此时循环节为\(\mathrm{GCD}(2,4,6,8)=24\)。 比赛时狂打1h，然后最后2分钟提交后发现T了。最后发现是G开大了…… （比赛后又对了一波拍，但是疯狂WA。假装A了） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int N=100+5,MOD=1000000007,G=24;struct Matrix&#123; ll m[N][N]; Matrix()&#123; memset(m,0,sizeof(m)); &#125; void Diag()&#123; for(int i=0;i&lt;N;i++)m[i][i]=1; &#125; Matrix operator*(const Matrix &amp;b)const&#123; Matrix ret; for(int i=0;i&lt;N;i++) for(int j=0;j&lt;N;j++) for(int k=0;k&lt;N;k++) ret.m[i][j]=(ret.m[i][j]+m[i][k]*b.m[k][j])%MOD; return ret; &#125; Matrix operator^(const int &amp;t)const&#123; Matrix bas=*this,ret; ret.Diag(); for(int i=t;i;i&gt;&gt;=1,bas=bas*bas) if(i&amp;1)ret=ret*bas; return ret; &#125;&#125;;ll QPow(ll bas,ll t)&#123; ll ret=1;bas%=MOD; for(;t;t&gt;&gt;=1,bas=bas*bas%MOD) if(t&amp;1LL)ret=ret*bas%MOD; return ret;&#125;int Inv(ll x)&#123; return QPow(x,MOD-2);&#125;int m,n,r[2],nMon,t;bool mon[G][N][N];Matrix mat[G][2],gcd[2];inline int Id(int r,int c)&#123; return r*m+c;&#125;inline ll Abs(int x)&#123; return x&gt;0?x:-x;&#125;inline int Dis(int x1,int y1,int x2,int y2)&#123; return Abs(x1-x2)+Abs(y1-y2);&#125;int main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;m&gt;&gt;r[0]&gt;&gt;r[1]&gt;&gt;nMon&gt;&gt;t; for(int i=1,x1,x2,y1,y2;i&lt;=nMon;i++)&#123; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; if(x1==x2)&#123; int dir=1,y=y1; for(int j=0;j&lt;G;j++)&#123; mon[j][x1][y]=1; int _y=y+dir; if(_y&gt;max(y1,y2)||_y&lt;min(y1,y2))dir*=-1; if(y1!=y2)y=y+dir; &#125; &#125;else&#123; int dir=1,x=x1; for(int j=0;j&lt;G;j++)&#123; mon[j][x][y1]=1; int _x=x+dir; if(_x&gt;max(x1,x2)||_x&lt;min(x1,x2))dir*=-1; if(x1!=x2)x=x+dir; &#125; &#125; &#125; for(int d=0;d&lt;=1;d++)&#123; gcd[d].Diag(); for(int i=0;i&lt;G;i++)&#123; for(int j=0;j&lt;n;j++) for(int k=0;k&lt;m;k++)&#123; if(mon[i][j][k])continue; int cnt=0; for(int p=0;p&lt;n;p++) for(int q=0;q&lt;m;q++)&#123; if(mon[(i+1)%G][p][q])continue; if(Dis(j,k,p,q)&lt;=r[d])cnt++; &#125; int inv=Inv(cnt); for(int p=0;p&lt;n;p++) for(int q=0;q&lt;m;q++)&#123; if(mon[(i+1)%G][p][q])continue; if(Dis(j,k,p,q)&lt;=r[d]) mat[i%G][d].m[Id(j,k)][Id(p,q)]=inv; &#125; &#125; gcd[d]=gcd[d]*mat[i][d]; &#125; &#125; Matrix vec[2]; vec[0].m[0][0]=1;vec[1].m[0][Id(n-1,m-1)]=1; for(int i=0;i&lt;=1;i++)&#123; vec[i]=vec[i]*(gcd[i]^(t/G)); for(int j=0;j&lt;(t%G);j++) vec[i]=vec[i]*mat[j][i]; &#125; ll ans=0; for(int i=0;i&lt;n*m;i++) ans=(ans+vec[0].m[0][i]*vec[1].m[0][i]%MOD)%MOD; cout&lt;&lt;ans; return 0;&#125; 总结 感觉没什么人打Codechef？（或者说这一场的Div.2没什么人打？） 水题设置得还行，最后出个原题感觉就有点没意思了。 第一次知道时区还有+5.5的地区。]]></content>
      <categories>
        <category>比赛</category>
        <category>Codechef</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一些小结论和随笔]]></title>
    <url>%2Fsummary%2Fsome-conclusion%2F</url>
    <content type="text"><![CDATA[记录一些平时看到的零散结论和一些to-do list。 仙人掌边数\(n-1 \leq m \leq 2n-2\) 特征多项式 Cayley-Hamiton uoj.ac/problem/200 \(\varphi(n)\)的\(n\)的级别 求\(1\to n​\)的所有约数级别 \(\sum_{i=1}^n \frac ni\)的级别 两段查表快速幂 扩展欧拉定理中可以直接用\(\mod\varphi(n)\)试乘的条件不成立：\(n=6\) \((-1)^{n-i}=(-1)^{n-i}(-1)^{2i}=(-1)^{n+i}\) TO-DO List min-max容斥 反演 二项式反演 Stirling反演 Stirling数]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[六省联考2017 分手是祝愿]]></title>
    <url>%2Fluogu%2F3750%2F</url>
    <content type="text"><![CDATA[Luogu 题解 按灯问题基本有两个性质： 按的顺序无关 一个灯按一次以上没有意义 剩下的部分就可以参考Sengxian's Blog了。 怎么能想到这种东西呢……递推期望的时候，一个状态\(f_i\)可能走到好几个状态，又走回来这个状态，可以得到一个\(f_i\)关于\(f_i\)能到达的状态\(f_j\)的式子，并且式子中很可能也有\(f_i\)自己。于是就可以愉快地解了。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//Zeit und Raum trennen dich und mich.#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;const int N=100000+5,MOD=100003,M=32+5;ll f[N],inv[N];ll QPow(ll bas,int t)&#123; ll ret=1;bas%=MOD; for(;t;t&gt;&gt;=1,bas=bas*bas%MOD) if(t&amp;1)ret=ret*bas%MOD; return ret;&#125;int n,lim;bool a[N];vector&lt;int&gt; d[N];int main()&#123; ios::sync_with_stdio(0); cin&gt;&gt;n&gt;&gt;lim; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j+=i) d[j].push_back(i); int cnt=0; for(int i=n;i&gt;0;i--)&#123; if(a[i])&#123; for(int j=0;j&lt;d[i].size();j++) a[d[i][j]]^=1; cnt++; &#125; &#125; ll ans=0,fac=1; for(int i=0;i&lt;MOD;i++) inv[i]=QPow(i,MOD-2); for(int i=n;i&gt;0;i--)&#123; if(i&gt;lim)f[i]=(f[i+1]*(n-i)+n)*inv[i]%MOD; else f[i]=1; if(i&lt;=cnt)ans=(ans+f[i])%MOD; fac=fac*i%MOD; &#125; cout&lt;&lt;ans*fac%MOD; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>概率与期望</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihocoder1869 Items]]></title>
    <url>%2Fhihocoder%2F1869%2F</url>
    <content type="text"><![CDATA[hihocoder 一句话题面：集合\(S=\{a_i\}\)（\(|S| \leq 3 \times 10^5\)），\(q\)次询问求是否存在一个子集\(S_0\subseteq S\)，使得\(\sum_{a_i\in S_0} a_i = r \pmod M\)（\(M \leq 3\times 10^5​\)）。 题解 具体请参考官方题解。 不得不说实在是很妙……在原有DP基础上为了加速转移，每次只更新可以更新的部分，跳过不能更新的部分。 每次加入元素\(a_i\)时，在一个可能是转移状态的位置之前，DP数组的前缀是相同的，因此把DP数组当成字符串二分LCP长度就可以找到这个位置。不能转移的情况是，更新之前这一位就是\(1\)，也就是没加入\(a_i\)时就可以取到了。 判断LCP用Hash即可，树状数组维护。这里学习到一个小技巧：普通Hash的MOD最好选择它的一个原根作做幂。记得提前算好原根的\(n\)次幂和对应的逆，不然就会像我一样疯狂TLE。 复杂度证明十分地巧妙，通过等价代换分析出了总更新次数。另外，这套题的B题用了排序不等式证明复杂度。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N=300000+5,MOD=998244353,G=3;typedef long long ll;int f[N];struct BITree&#123; ll t[N]; int Lowbit(int x)&#123; return x&amp;-x; &#125; void Add(int p,ll v)&#123; for(;p&lt;N;p+=Lowbit(p)) t[p]=(t[p]+v)%MOD; &#125; ll Query(int p)&#123; ll ret=0; for(;p;p-=Lowbit(p)) ret=(ret+t[p])%MOD; return ret; &#125;&#125;;inline ll QPow(ll bas,ll t)&#123; ll ret=1;bas%=MOD; for(;t;t&gt;&gt;=1,bas=bas*bas%MOD) if(t&amp;1LL)ret=ret*bas%MOD; return ret;&#125;inline ll Inv(ll x)&#123; return QPow(x,MOD-2);&#125;BITree t;ll pow3[N],inv3[N];void InitHash()&#123; pow3[0]=1; for(int i=1;i&lt;N;i++) pow3[i]=pow3[i-1]*G%MOD; for(int i=0;i&lt;N;i++) inv3[i]=Inv(pow3[i]);&#125;ll Hash(int l,int r)&#123; ll ret=(t.Query(r)-t.Query(l-1))%MOD; ret=ret*inv3[l-1]%MOD; return (ret+MOD)%MOD;&#125;int n,m;ll det;inline bool Check(int st1,int st2,int M)&#123; ll h1=(Hash(st1,st1+M-1)+det)%MOD; ll h2=Hash(st2,st2+M-1); return h1==h2;&#125;int BSearch(int L,int R,int st1,int st2)&#123; while(L&lt;R)&#123; int M=(L+R)/2; if(Check(st1,st2,M))L=M+1; else R=M; &#125; return L;&#125;int q[N];int main()&#123; InitHash(); scanf("%d%d",&amp;n,&amp;m); f[1]=1; t.Add(1,pow3[1]); for(int i=1,a,len;i&lt;=n;i++)&#123; scanf("%d",&amp;a); q[0]=0; //q: update det=0;len=1; while(Check(1,1+a,m-a)==0)&#123; len=BSearch(len,m-a,1,1+a); if(f[len]==0&amp;&amp;f[a+len]==1) det=(det+pow3[len])%MOD; else&#123; det=(det+MOD-pow3[len])%MOD; q[++q[0]]=a+len; &#125; &#125; det=0;len=1; while(Check(m-a+1,1,a)==0)&#123; len=BSearch(len,a,m-a+1,1); if(f[m-a+len]==0&amp;&amp;f[len]==1) det=(det+pow3[len])%MOD; else&#123; det=(det+MOD-pow3[len])%MOD; q[++q[0]]=len; &#125; &#125; for(int j=1;j&lt;=q[0];j++)&#123; t.Add(q[j],pow3[q[j]]); f[q[j]]=1; &#125; &#125; int nQ; scanf("%d",&amp;nQ); while(nQ--)&#123; int r; scanf("%d",&amp;r); printf(f[r+1]?"YES\n":"NO\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>动态规划</tag>
        <tag>数据结构</tag>
        <tag>LCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog渲染测试]]></title>
    <url>%2Fblog%2Fblog-renderer-test%2F</url>
    <content type="text"><![CDATA[这是一个测试博客格式与渲染的页面。 一级标题（blog标题） 然后是二级标题 这个是三级标题 接下来是四级标题 基本不怎么用到的五级标题 This sentence is written in English. 这一行文字是中文测试。 那么斜体、粗体、下划线和删除线呢？ 采用theme-next-pangu，在English和中文之间会automatically加入space的function的测试，但是要保证特殊字形之间不能发生变化。 ​ 这一段文字是采用了首行缩进的功能。但是事实上的效果好像并没有首行缩进。 测试无序列表 无序列表-sub 无序列表-sub-sub 无序列表-sub-sub-sub 测试有序列表1 有序列表2 有序列表3 渲染mathjax时，文字间公式\(\sum_{i=1}^n a_i^p \pmod {998244353}\)是这样的。下面给出一行的公式： \[\mathrm{maximize} \prod _{i=1}^n b_i\] 修改转义字符：\(H=-\sum*{i=1}^N (\sigma*{i}^x \sigma*{i+1}^x+g \sigma*{i}^z)\) 在hexo-renderer-kramed下修改转义字符后仍不能正常显示上面一行的公式。 在hexo-renderer-pandoc下可以正常显示上面一行的公式。 插入一个图片： 插入一个超链接。 插入一个内联代码，或者是Inline Code。 插入一个脚注1。 插入一段快速幂板子： 12345678typedef long long ll;const ll MOD=998244353;ll QPow(ll bas,ll t)&#123; ll ret=1; for(;t;t&gt;&gt;=1,bas=bas*bas%MOD) if(t&amp;1LL)ans=ans*bas%MOD; return ret;&#125; 插入一段引用。 起床起床快起床，背航概，背航概的孩子都是上辈子折了边条翼三角翼翼梢小翼大展弦比平直机翼襟翼副翼水平尾翼垂直尾翼固定后掠翼可变后掠翼，失去了活塞式发动机涡轮喷气式发动机涡轮螺桨发动机涡轮桨扇发动机涡轮风扇发动机涡轮轴发动机冲压发动机组合式发动机液体火箭发动机固体火箭发动机固液混合火箭发动机并且遇到了大激波阻力干扰阻力压差阻力诱导阻力粘性摩擦阻力声障热障，导致进入过失速状态尾旋状态并且改出失败以致失去了侧向无线电导航测距无线电导航测距差无线电导航测速无线电导航平台式惯性导航捷联式惯性导航卫 星导航地形匹配导航景象匹配导航天文导航和各种组合式导航，最后死于弹道导弹战术导弹战略导弹集束导弹分导导弹机动导弹近程导弹中程导弹远程导弹州际导弹的瞄准线指令制导非瞄准线指令制导驾束制导被动寻的制导主动寻的制导半主动寻的制导TVM制导雷达制导红外制导电视制导激光制导光纤制导卫星制导下的F15F16F18su27su30歼567歼10 11直58911强5b2b52运5运10北京1号。 这是一个脚注。↩]]></content>
      <categories>
        <category>博客建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo的一些参考资料]]></title>
    <url>%2Fblog%2Freference-to-build-hexo%2F</url>
    <content type="text"><![CDATA[一些配置hexo和nexT时参考的文章。 http://theme-next.iissnan.com/theme-settings.html#tags-page https://hexo.io/zh-cn/docs/ https://www.jianshu.com/p/3ff20be8574c https://github.com/theme-next/hexo-theme-next/tree/master/docs/zh-CN https://blog.csdn.net/Sugar_Rainbow/article/details/57415705 https://www.jianshu.com/p/3a05351a37dc https://www.jianshu.com/p/02fbd409988c http://www.hahack.com/codes/from-ruhoh-to-hexo/ https://segmentfault.com/a/1190000007261752 https://segmentfault.com/q/1010000003987383 https://github.com/wzpan/hexo-renderer-pandoc http://shomy.top/2016/10/22/hexo-markdown-mathjax/ https://blog.csdn.net/msw521sg/article/details/53331033 https://blog.csdn.net/robertsong2004/article/details/54907381 npm install hexo-renderer-pandoc --save pangu.js for nexT]]></content>
      <categories>
        <category>博客建设</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串算法总结]]></title>
    <url>%2Fsummary%2Fstring-algorithm%2F</url>
    <content type="text"><![CDATA[竞赛中的字符串算法并不算少，可惜我在字符串上也拿不出手来。因此本篇只是简单总结，将来（咕）还会渐渐完善内容。 字符串算法通常是对一个或多个字符串进行匹配。然而这些算法不但不容易记忆且容易出错，因此尽可能保证一次写对是很重要的。 KMP KMP是多个文本串匹配一个模板串的算法。它通过预处理模板串构造失配边，使得匹配失败的移动代价减小。失配边作用即是，从失配的一位顺着失配边走，则在失配边所在节点之前跟文本串都是匹配的。 初始化模板串的过程就是自己匹配自己的过程。具体流程如下： 从第\(i\)位开始匹配； 不断沿着失配边走，直到其等于第\(i\)位（此过程中前\(i-1\)位保证匹配）； 如果当前位置结尾的串与第\(i\)位结尾的串匹配，将此失配边赋给\(i+1\)； 否则当前位置是第\(0\)位，将\(0\)赋给\(i+1\)。 给出代码。 12345678int Init(int f[],string s)&#123; f[0]=f[1]=0; for(int i=1;i&lt;s.length();i++) &#123; int j=f[i]; while(j&amp;&amp;s[i]!=s[j])j=f[j]; f[i+1]=s[i]==s[j]?j+1:0; &#125; &#125; 注意的点： 执行失配的是第\(i\)位，但正在计算的是第\(i+1\)位的失配 如果结尾不匹配，则失配边连向开头 明白了初始化，查询的代码也不难写。 123456789int KMP(string s,string t,int f[])&#123; int cnt=0,j=0; for(int i=0;i&lt;s.length();i++)&#123; while(j&amp;&amp;s[i]!=t[j])j=f[j]; if(s[i]==t[j])j++; if(j==t.length())cnt++; &#125; return cnt;&#125; 需要用变量\(j\)记录当前文本串的匹配长度。 \(i\)的值表示当前正在匹配第\(i\)位 是查询t在s上出现的位置（和上文的s不一样） KMP的预处理复杂度和匹配复杂度都是线性的。（具体的证明我忘了，蓝书上有。）我们观察这个\(f\)数组（也叫fail数组），它也有很多不错的性质。 \(f_{i+1}\)同时表示前缀\(i\)的首尾相同部分子串最大长度（Border）。我们发现，如果\(f_{n+1}=j\)，则\(n+1-j\)是长度为\(n\)的串的最小循环节（不一定完整）。这个性质可以证明，也可以画图理解。因此利用KMP可以求一个串的最小循环节。不断顺着失配边走，可以得到串从小到大的周期。 所有的失配边构成了一棵树，且标号严格递增，是小根堆。由于一个节点表示了一个原串的Border，所以可以通过在失配树上爬得到所有的Border。 KMP树不断失配得到的序列，能被分为不超过\(\log n\)个等差数列。（没有看懂） 需要更多补充。WC2017的讲义里应该是有的。 扩展KMP 没有学习，很绝望。等待填坑。 Border Tree 没有学习，很绝望。等待填坑。 ##AC自动机 适用于多模板匹配。想到KMP是字符串+失配边，则多模板的AC自动机是Trie+失配边。其建树过程和KMP基本相同。 1234struct AhoCorasick&#123; int ch[SIZ][CHAR],f[SIZ],suf[SIZ]; bool isEnd[SIZ];&#125;; 其中\(f\)是失配边，\(ch\)是Trie，\(isEnd\)表示节点\(i\)是否为单词结尾，而\(suf\)为上一个单词节点。不加解释地给出初始化代码： 1234567891011121314151617void GetFail()&#123; queue&lt;int&gt; q; for(int i=0;i&lt;CHAR;i++) if(ch[0][i])q.push(ch[0][i]); while(!q.empty())&#123; int h=q.front();q.pop(); for(int i=0;i&lt;CHAR;i++)&#123; int &amp;u=ch[h][i],j=f[h]; if(!u)&#123;u=ch[j][i];continue;&#125; q.push(u); while(j&amp;&amp;!ch[j][i])j=f[j]; f[u]=ch[j][i]; suf[u]=isEnd[f[u]]?f[u]:suf[f[u]]; &#125; &#125;&#125; 这个代码直接将不匹配的边改为失配边，这样查询时就可以直接在树上爬而不考虑失配数组啦。其中\(suf\)的作用是输出该节点结尾的全部单词，因为一个单词节点可能有多个单词。 //此处应该有查询的代码，等待补全 AC自动机的构建与查询都是线性的，一点证明可以看这里。但是AC自动机似乎没有什么良好的性质可以使用，因此往往结合着考吧。（什么？可持久化Trie？） 后缀数组 后缀数组似乎不需要对构造的过程有太多理解，因为写了第一次之后基本就复制粘贴了。后缀数组的重点在记录排名为\(k\)的\(sa\)数组，记录后缀\(k\)的排名\(rnk\)数组和记录\(LCP_{sa_{i-1},sa_i}\)的\(hei\)数组。 可以参考09年论文：《后缀数组——处理字符串的有力工具》罗穗骞。下面就直接丢代码了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct SuffixArray&#123; int sa[N],hei[N],rnk[N]; void Init(int *a,int n)&#123; InitSa(a,n); InitHeight(a,n); for(int i=0;i&lt;n;i++)&#123; sa[i]=sa[i+1]; hei[i]=hei[i+1]; rnk[i]--; &#125; &#125; inline bool Cmp(int *a,int x,int y,int l)&#123; return a[x]==a[y]&amp;&amp;a[x+l]==a[y+l]; &#125; void InitSa(int *a,int n)&#123; int m=26; static int tmpX[N],tmpY[N],s[N]; int *x=tmpX,*y=tmpY; a[n]=0; for(int i=0;i&lt;m;i++)s[i]=0; for(int i=0;i&lt;=n;i++)s[x[i]=a[i]]++; for(int i=1;i&lt;m;i++)s[i]+=s[i-1]; for(int i=n;i&gt;=0;i--)sa[--s[x[i]]]=i; for(int i=1,p=1;p&lt;=n;i&lt;&lt;=1,m=p)&#123; p=0; for(int j=n-i+1;j&lt;=n;j++)y[p++]=j; for(int j=0;j&lt;=n;j++)if(sa[j]&gt;=i)y[p++]=sa[j]-i; for(int j=0;j&lt;m;j++)s[j]=0; for(int j=0;j&lt;=n;j++)s[x[y[j]]]++; for(int j=1;j&lt;m;j++)s[j]+=s[j-1]; for(int j=n;j&gt;=0;j--)sa[--s[x[y[j]]]]=y[j]; swap(x,y); p=1,x[sa[0]]=0; for(int j=1;j&lt;=n;j++)x[sa[j]]=Cmp(y,sa[j-1],sa[j],i)?p-1:p++; &#125; &#125; void InitHeight(int *a,int n)&#123; for(int i=1;i&lt;=n;i++)rnk[sa[i]]=i; for(int i=0,j,k=0;i&lt;n;hei[rnk[i++]]=k) for(k?k--:0,j=sa[rnk[i]-1];a[i+k]==a[j+k];k++); &#125;&#125;; 注意上面代码的\(a\)数组范围为\([0,n)\)，初始化时要把\(a_n\)赋一个比其他字符都小的字符。\(m\)为字符集最大值\(+1\)，即\(1\leq a_i&lt; m\)。由于一些特殊原因，最后的数组是包含\(a_n\)的，显然\(a_0=n\)，我们需要把数组调整位置。具体流程： 利用\(a\)进行基数排序，此时\(x\)为\(rnk\)数组。（如果\(m\)很大，使用快排离散化）； 倍增长度，用\(sa\)数组计算的对第二关键字排序的\(y\)数组来计算\(sa\)数组； 交换\(x,y\)，计算\(x\)数组。若当前二元组数\(\leq n\)，跳至第二步。 \(hei\)的求法是利用了\(hei_{rnk_i}\geq hei_{rnk_i-1}-1\)（具体解释见训练指南）。 利用后缀数组求LCP 不难证明两个后缀\(i,j(rnk_i&lt;rnk_j)\)有： \[LCP_{i,j}=min\{hei_k\}\quad rnk_i&lt; k\leq rnk_j\] 这是个RMQ问题，因此我们可以\(\mathrm{O}(nlogn)\)预处理ST表\(\mathrm{O}(1)\)回答。 LCP可以解决多字符串的匹配问题，如询问多串字符串中长度最大且出现了至少\(k\)次的子串。这只需要二分长度\(len\)，每一次按\(sa\)顺序考察是否有长度为\(len\)且\(LCP\geq k\)的序列（使用单调队列）。 后缀自动机 几个参考资料： 陈立杰WC2015讲义 2015年国家集训队论文《后缀自动机及其应用》张天扬 12345678910111213141516171819202122232425262728293031namespace SAM&#123; int ch[N][C],pa[N],len[N],siz[N]; int idx=1,pre=1; void Insert(int x)&#123; int p=pre,np=++idx;pre=np; siz[np]=1;len[np]=len[p]+1; for(;p&amp;&amp;ch[p][x]==0;p=pa[p])ch[p][x]=np; if(p==0)pa[np]=1; else&#123; int q=ch[p][x]; if(len[q]==len[p]+1)pa[np]=q; else&#123; int nq=++idx;len[nq]=len[p]+1; memcpy(ch[nq],ch[q],sizeof(ch[q])); pa[nq]=pa[q];pa[q]=pa[np]=nq; for(;p&amp;&amp;ch[p][x]==q;p=pa[p])ch[p][x]=nq; &#125; &#125; &#125; int tmp[N],topo[N]; void Build()&#123; //用拓扑关系\mathrm&#123;O&#125;(n)求得每个节点的siz for(int i=1;i&lt;=idx;i++)tmp[len[i]]++; for(int i=1;i&lt;=idx;i++)tmp[i]+=tmp[i-1]; for(int i=1;i&lt;=idx;i++)topo[tmp[len[i]]--]=i; for(int i=idx;i&gt;1;i--)&#123; int v=topo[i];int u=pa[v]; siz[u]+=siz[v]; &#125; 每次插入的np都代表了原串的一个前缀，故其right设为1，最后再用拓扑统计一下siz即可。 广义后缀自动机 还是没有看懂。待补。 回文串 Manacher Manacher算法就是用已得到的回文串条件来简化一些不必要的判断。假如\(A，B\)串是回文串，且\(B\)串在\(A\)串回文中心左侧，则\(B\)串关于\(A\)的回文中心对称串\(B&#39;\)也是回文串。 用\(f_i\)表示从\(i\)开始还能向两周扩展多少字符。记录\(i\)之前的\(i+f_i\)最大值\(cur\)（也就是当前最远的回文串右端点）与编号\(idx\)，则若\(i\)在\(cur\)内，长度有可能为\(i\)关于\(idx\)对称的位置的\(f\)值（\(i+f_i\)完全在\(idx\)的回文串内），也有可能为\(cur-i\)（\(i+f_i\)超出\(cur\)部分的不能保证长度一定等于\(i\)关于\(idx\)对称的\(f\)值）。接着就暴力向右匹配，尝试增加\(f_i\)。因为每一次的暴力匹配只会从\(cur\)向右的位置开始匹配（在\(cur\)内匹配一次就会失配），而\(cur\)会不断向右移动，最终\(cur=n\)。因此Manacher的时间复杂度是\(\mathrm{O}(n)\)的。 具体流程： 初始化\(f_0=0,cur=0,idx=0\)； 对每一个i： \(f_i=min(f_{2*idx-i},cur-i)\)； 尝试扩展\(f_i\)； 更新\(cur\)。 给出实现。 12345678910111213141516int Manacher()&#123; int len=strlen(tmp); for(int i=0;i&lt;len;i++)str[i*2+1]='#',str[i*2+2]=tmp[i]; str[len=len*2+1]='#';str[0]='*',str[len+1]='$'; int cur=f[0]=0,idx=0,ans=1; //cur为最远能到达的字符 for(int i=1;i&lt;=len;i++) &#123; int&amp; j=f[i];j=0; if(cur-i&gt;=0&amp;&amp;2*idx-i&gt;=0)j=min(f[2*idx-i],cur-i); while(str[i-j-1]==str[i+j+1])j++; if(i+j&gt;cur)cur=i+j,idx=i; ans=max(ans,(j*2+1)/2); &#125; return ans;&#125; 容易发现Manacher的回文是以字符为回文中心的，如果要求字符间为中心需要在所有字符间加一个相同的字符。为了方便匹配，我们设置第一个字符与最后一个字符为两个从未出现的、不同的字符，以此避免一些特判。 一些性质 Manacher得到的其实是本质不同的回文串（并且数量上是\(\mathrm{O}(n)\)级别的）。一个例题：万径人踪灭。 回文自动机 几个参考资料： 2017年国家集训队论文《回文树及其应用》翁文涛 12345678910111213141516171819202122232425262728293031323334namespace PAM&#123; int ch[N][C],pa[N]=&#123;1&#125;,len[N]=&#123;0,-1&#125;,siz[N]; int idx=1,pre=0; void Insert(char *s,int pos)&#123; int p=pre,x=s[pos]-'a'; for(;s[pos-len[p]-1]!=s[pos];)p=pa[p]; if(ch[p][x]==0)&#123; int q=pa[p],np=++idx; len[np]=len[p]+2; for(;s[pos-len[q]-1]!=s[pos];)q=pa[q]; pa[np]=ch[q][x];ch[p][x]=np; &#125; pre=ch[p][x];siz[pre]++; &#125; ll Build()&#123; ll ans=0; for(int i=idx;i&gt;1;i--)&#123; siz[pa[i]]+=siz[i]; ans=max(ans,1LL*siz[i]*len[i]); &#125; return ans; &#125;&#125;;char s[N];int main()&#123; scanf("%s",s+1);s[0]='#'; int n=strlen(s)-1; for(int i=1;i&lt;=n;i++) PAM::Insert(s,i); printf("%lld",PAM::Build()); 注意第二次找\(fail\)边时如果指向odd，则需要指向even，这也解释了为什么需要把even放在节点0（odd节点不存在转移时可以直接转移到0）。 一些性质 回文自动机除了odd和even节点的数目是原串中本质不同的回文串数目，其代表了一个从根节点到该节点的回文子串。 练习 KMP POJ1961 Period 题意：求前缀串的循环节。 根据fail数组的性质，只要处理出\(fail\)数组找Border即可。 HNOI2008 GT考试 用\(dp_{i,j}\)表示匹配完\(i\)位没出现不吉利数字，且末尾最长能匹配不吉利号码的前\(j\)位，则有： \[dp_{i,j}=\sum(dp_{i-1,k})\quad\text{(去除当前最后一个字符最长能匹配不吉利号码的前k位)}\] 发现这个关系就是KMP的失配边关系，因此预处理出fail数组即可。但是\(n\)很大，同时\(m\)很小，且转移为线性，因此可以利用矩阵快速幂解决，时间复杂度\(\mathrm{O}(n\log^3{m})\) NOI2014 动物园 貌似是倍增。但是不会写。 扩展KMP 哈？ AC自动机 JSOI2007 文本生成器 题意：求长度为\(M\)的串中包含至少一个\(N\)单词字典的单词方案数。 "至少一个"不容易计算，考虑计算"一个都不生成"，理由是串的总方案数是已知的：\(26^M\)。因此我们只需要求在fail树上走\(M\)步不经过单词节点的方案数。规模较小，可以采用动态规划。 POJ2778 DNA Sequence 题意：求长度为\(M\)的串中不包含\(N\)单词字典的单词方案数。 和上题一样，但是\(M\)可以很大\((2\times 10^9)\)。字典单词数和单词长度都较小，因此可以构造矩阵判断是否能转移，矩阵快速幂即可。 TJOI2013 单词 如果直接建树并在文章串上扫一遍极有可能会空间爆炸，因此换个角度思考。 一个串如果包含另一个串，则它们在树上是可以沿着失配边到达的。因此可以在构造fail树的时候记录哪些节点fail会到达自己，并加上这些节点被到达的次数即可。更具体化，令\(cnt_u\)为\(u\)节点（单词）的包含次数，则： \[cnt_u=\sum cnt_v\quad(u\in fail_v)\] 初始化没有被包含的单词出现次数为\(1\)，时间复杂度为\(\mathrm{O}(n)\)。 后缀数组 POJ1743 Musical Theme 题意：寻找长度大于\(5\)的、长度最长且不重叠的子串，且子串的差分数组相同。 因此直接在差分数组上匹配LCP就好了。二分答案\(ans\)，每次将\(hei\)分成LCP不大于\(ans\)的许多组，并判定是否存在一组的最前出现位置与最后出现位置间隔大于\(ans\)。由于是在差分数组上处理，有些细节需要注意（如只需要匹配\(4\)个）。 USACO2006DecGold Milk Patterns 二分答案\(ans\)，每次将\(hei\)分成LCP不大于\(ans\)的许多组，判定是否存在个数大于\(k\)的组。 POJ3294 Life Forms 题意：求至少在一半的字符串中出现的所有最长子串并输出。 和多字符串与LCP有关的题目往往需要把所有字符串接起来，中间用不同且未出现过的分隔符隔开。然后就比较套路了：二分长度\(ans\)，每次将\(hei\)分成LCP不大于\(ans\)的许多组，判定是否存在DNA来源数至少有一半的组。这个只需要用一个时间戳记录当前所在组编号和各DNA串最近一次出现的时间戳，这样就能动态维护当前有几个来源不同的DNA串了，顺便记录输出的位置。 POJ3415 Common Substrings 题意：给出\(A,B\)串和限制\(lim\)，求满足\(A_{i,i+k-1}=B_{j,j+k-1}\)的方案数的三元组\((i,j,k)\ (k\geq lim)\)的数量。 好题，但是写起来一点也不优美（我写得太丑了）。不难看出一对LCP不小于\(lim\)的位置\(i,j\)的贡献是\(LCP_{i,j}-lim+1\)，然而我们没办法枚举全部的\(i\)和\(j\)，这种时候一般可以维护每次向后移动，前面的字符对答案的贡献。 由于\(hei\)的单调性，在扫\(sa\)序列的过程中可以用个单调栈维护当前字符到前面所有非自己所在串（即当前字符是A串就保存B串）的LCP和个数，并维护当前总贡献数。每次向后移动时修改，每次是自己串就统计答案。要对两个串分别做一次，记得long long。 字符串题目中常常出现这种二维匹配计数，此时往往不能直接枚举计数。一般可以枚举\(LCP_{i,j}\)再统计对数，或者只枚举一个，另一个通过维护总贡献实现。这个想法在莫比乌斯反演的变换也有体现。 AHOI2013 差异 可以分成两部分\(\sum_{1\leq i&lt;j\leq n} len_i+len_j\)和\(\sum_{1\leq i&lt;j\leq n} len_{LCP_{i,j}}\)来求。 手推一下可以得到前半部分的答案是\(\frac {(n-1)n(n+1)}2\)，后半部分和上一题类似，维护一个\(hei\)的单调栈就可以动态计数了。 JSOI2008 火星人 住口，你根本不是后缀数组！ 后缀自动机 TJOI2015 弦论 在SAM上统计后续状态数量，进行一次DFS即可。 AHOI2013 差异 这个题用SAM做就很舒服了。 两个后缀的\(\mathrm{LCP}(i,j)\)为\(i,j\)代表的后缀在树上的\(\mathrm{LCA}(i,j)\)的\(len\)，故在\(fail\)树上标记一下原串中的后缀，并且对每个节点都统计一下子树中有多少对节点的\(\mathrm{LCA}\)为它即可。 NOI2015 品酒大会 本质上是求\(\mathrm{LCP}(i,j) = p\)的数目，就和上一题一样了。 在统计每个节点的时候，顺便合并一下子树里的最大次大、最小次小值（有可能负负得正）。 回文自动机 APIO2014 回文串 PAM模板题。 总结 字符串算法固然重要，但是理解更为重要（除了后缀数组）。搞清楚fail数组的性质会对一些题目有所帮助，尤其是Trie树上的fail可以是某种动态规划的转移来源。 沿着KMP的失配边走可以得到字符递增的循环节，因此可以求周期。 当单词数不多时，如果有需要可以构造矩阵进行转移。 通常和后缀数组有关的题目出现多字符串，需要将其连在一起并用不同且没出现过的字符隔开。 字符串题目中常常出现这种二维匹配计数，此时往往不能直接枚举计数。一般可以枚举\(LCP_{i,j}\)再统计对数，或者只枚举一个，另一个通过维护总贡献实现。这个想法在莫比乌斯反演的变换也有体现。]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态规划总结]]></title>
    <url>%2Fsummary%2Fdynamic-programming%2F</url>
    <content type="text"><![CDATA[主要说明优化DP的一些方法。 四边形不等式 四边形不等式是一个神奇的二元函数的结论，利用它可以得到决策的单调性，从而加速寻找转移状态的时间。然而我对这个东西并没有研究，因此也只能谈一下结论。 对函数\(w_{i,j}\)，若满足 \[w_{i,j}+w_{i&#39;,j&#39;}\leq w_{i,j&#39;}+w_{i&#39;,j} \quad (i\leq i&#39;\leq j\leq j&#39;)\] 则函数\(w_{i,j}\)满足四边形不等式。令\(s_{i,j}\)表示\(w_{i,j}\)得到最优值的转移来源，则有： \[s_{i,j}\leq s_{i,j+1}\leq s_{i+1,j+1} \quad (i\leq j)\] 即决策具有单调性。利用这个性质可以缩小决策集合，加速决策时间。但是不等式仅仅缩小了范围，并不意味着当一个决策比之前的决策和后一个决策更优时，就不继续考察后面的决策。 （其实还有一个区间包含单调不等式，但是我没看出来有什么用） ##斜率优化 斜率优化是优化一类动态规划的方法，通常的实现是维护一个凸包从而达到\(\mathrm{O}(\log {n})\)甚至\(\mathrm{O}(1)\)的转移时间复杂度。维护凸包通常采用单调队列或平衡树。 ###一般情况 从典型的情况着手。假设我们有一个转移方程： \[f_i=min\{-a_i*b_j+c_j\}+d_i \quad (0\leq j&lt;i)\] 很明显，这个方程在朴素的情况下需要对每个\(i\)枚举\(j\)，时间复杂度是\(\mathrm{O}(n^2)\)的。但是我们发现这个方程与\(i\)和\(j\)有关的项只有一项，而其他项要么只与\(i\)有关，要么只与\(j\)有关。令\(x=b_j,y=c_j,d_i=t\)，则对确定的\(j\)，\(x\)与\(y\)都是确定的。假设此时\(j\)为最优转移。代入有： \[ \begin{align} f_i&amp;=-a_i*x+y+t \\ \Rightarrow y&amp;=a_i*x+f_i-t \end{align} \] 由于\(t\)只与\(i\)相关，因此我们可以认为\(y = a_i x+f_i\)。此时我们相当于在满足\((0\leq j&lt;i)\)的\(j\)所代表的点集中，找到使得斜率\(k=a_i\)的直线在\(y\)轴上的截距最小的点。不难看出这个点只能在点集的下凸包上，否则其他点都没有该点优。因此我们需要维护一个下凸的点集（相邻边斜率递增）。 ####排除不必要点 考虑在候选点集里，哪些点是不必要的。方便考虑，我们先假设\(a_i\)非降，\(b_j\)严格递增，则插入点是按横坐标顺序排列的。由于斜率非降，我们通过画图可以知道若点\(j\)最优化了\(i\)，则对\(\forall i&#39;&gt;i\)，其最优转移都不可能在\(j\)之前的点\(k\)取到（斜率非降\(\Leftrightarrow\)极角非降，考虑旋转卡壳的过程对蹱点的单调转移），因此转移单调，可以删除\(j\)前面的点。 再考虑插入新点\(i\)的情况。如果当前加入了\(i\)会使得下凸性质被破坏，则当前点集最后一个点必定在下凸的上方，也就不会再被选中，直接删除。这个判断如果直接比较斜率容易出现精度误差甚至斜率不存在，我更喜欢用叉积计算。 这样，我们相当于在点集开头与结尾维护了下凸性质，并动态删除多余的点。这个数据结构可以采用双端队列，队首就是最佳转移。每个点最多入队出队一次，均摊时间复杂度为\(\mathrm{O}(1)\)。同理，如果函数转移最大值，则需要维护上凸性质。具体维护什么还要由点集的给出顺序（即\(x_i\)的趋势，如逆序给出需要逆序维护凸包）而定。 ###更一般的情况 我们以上维护凸包的讨论是建立在\(a_i\)（斜率）非降，\(b_j\)（横坐标）严格递增的情形上。假如不满足呢？ ####斜率无序 斜率无序，则决策单调性不满足，我们需要二分找到凸包上的切点。不难看出目标函数的斜率在最佳转移两侧的斜率之间。查找的时间复杂度为\(\mathrm{O}(\log n)\)。 ####横坐标无序 横坐标无序，则不能直接在队尾插入，需要一个能动态维护序列的数据结构——平衡树。查找到要插入的位置后，维护插入点左右的凸包性质。需要特判点在凸包内的情况，这样的点不会更新凸包。如果使用了叉积，就不需要考虑重点或重横坐标的情况。 当然如果斜率和横坐标都无序，那就只能考虑平衡树上的凸包维护。注意细节。 ##练习 斜率优化的题目我没做很多，不过感觉都是套路（除了诗人小G）。 ###基础 ####HDU3507 打印文章 令\(sumC _i = \sum _{j=1}^i c_j\)，则有： \[ \begin{align} f_i&amp;=min/max\{f_j+(sumC_i-sumC_j + M)^2\} \\ &amp;=min/max\{-2*sumC_i*sumC_j-2*sumC_j*M+f_j+sumC_j^2\} + (sumC_i+M)^2\\ \end{align} \] 同时维护两个凸包。 ####HNOI2008 玩具装箱 令\(sumC _i = \sum _{j=1}^i c_j\)，则有 \[f_i=min\{f_j+(i-j-1+sumC_i-sumC_j - L)^2\}\] 发现\(i\)有两个变化量\(i\)与\(sumC_i\)，不好处理。但是我们能够合并。重新定义\(sumC_i=sumC_i+i\)，则： \[f_i=min\{f_j+(sumC_i-sumC_j -L-1)^2\}\] 展开式子维护下凸包。 ####ZJOI2007 仓库建设 维护下凸包。题目应该有特判：只要最后的工厂是空的，就不用都运到最后一个工厂，这样费用反而会变小。不过数据没有这种坑点，因此直接输出\(f_n\)也没问题。 ####CEOI2004 锯木厂选址 不用随机算法就水水的。枚举第二个厂\(i\)与第一个厂\(j\)，化好式子之后发现\(x\)是递增的，斜率是非降的，直接队列就可以，不需要平衡树。 ###进阶 ####SDOI2012 任务安排 这个题明显有后效性，每次分配一段工作就对后面的完成时间增加\(S\)。我们发现对确定的分段\(i\)，其对后面的影响（假设对自己的影响已经计算了）是确定的值\(S*\sum_{j=i+1}^n\)，因此如果我们提前计算影响，就可以消除后效性。 令\(sumT_i=\sum_{j=1}^i T_j,sumF_i=\sum_{j=1}^i F_j\)，则： \[f_i=min\{f_j+[sumT_i+S*(sumF_n-sumF_j)]*(sumF_i-sumF_j)\}\] 明显展开后\(x=sumF_j,k_i=sumT_i\)，然而坑点是有\(t\leq0\)的数据,\(sumT_i\)不一定递增。需要二分寻找最优转移。 ####BSOJ1517 斜率优化 题意：给定\(a,b\)数组与\(f_i= \begin{cases} 0, &amp;i=0 \\ min\{f_j-a_i*b_j\}, &amp;0\leq j&lt;i\leq n \end{cases}\)，\(minimize\ f_n\)。 坐标和斜率都不单调，上平衡树维护。可以用Splay，我用的是非旋转式Treap。比较惊讶于我的寻找是Split+Merge+BSearch，总时间复杂度为\(\mathrm{O}(n\log ^2n)\)，竟然也跑得过\(n\leq 200000\)，感觉奥妙重重。 ###高级 没做过高级的。至少还没做完货币交换。 ####NOI2009 诗人小G 明显跟内容无关，我们只需要每一行的长度\(len_i\)。令\(sumLen_i=\sum_{j=1}^i len_j\)，再令\(sumLen_i=sumLen_i+i\)，则有： \[ f_i=min\{f_j+|(sumLen_i-sumLenj-1-L)^p|\} \] 对于\(p=2\)的点就是基础的斜率优化，可以过两个数据点。然而\(p\leq 10\)，没办法斜率优化。打个表发现决策具有单调性，然后我们也可以（通过复杂的）证明得到这个式子满足四边形不等式\(\Leftrightarrow\)决策具有单调性，就可以维护啦。 具体来说，我们插入时考虑决策\(i\)可能是哪些状态的最优决策，用\(a_i\)表示\(i\)的最优决策的最大值，则不难看出\(a_i\)是非降的。因为决策单调，决策\(j\)如果是\(i\)的最优决策，则\(i\)后面的所有状态的可能最优决策都更新为\(j\)。我们可以用栈维护每个决策能更新的状态的起始点，一个决策一旦被覆盖就不可能再出现。步骤如下： 对栈顶元素\(top\)的起始点\(pos_{top}\)考察用当前决策\(i\)是否会更优，是则出栈，否则重复。 此时决策\(i\)的起始点一定在\((pos_{top},n]\)之间，二分查找\(pos_i\)。 每次寻找最优决策时间二分\(\mathrm{O}(\log n)\)（如果维护队列为\(\mathrm{O}(1)\)），维护栈时每个元素最多出栈入栈一次，平摊\(\mathrm{O}(1)\)，二分\(\mathrm{O}(\log n)\)。所以单次数据复杂度为\(\mathrm{O}(n\log n)\)，完美解决。 不过严格来说，这跟斜率优化没有太大关系，重点在转移单调。 ##总结 斜率优化维护一个凸包从而达到\(\mathrm{O}(\log n)\)甚至\(\mathrm{O}(1)\)的转移复杂度，从而加速转移。一般需要转移具有单调性，可以通过四边形不等式证明。具体有几个要点： 转移表达式只与当前状态\(i\)与候选状态\(j\)有关，而不与其他变量\(k\)有关；或与\(k\)有关，但在\(k\)确定时\(i\)只与\(j\)有关。这样确保了二维平面上每个候选状态点\(j\)的存在。 斜率优化中，表达式的\(x\)值为与\(i\)相关的\(j\)的变量，\(y\)值为只与\(y\)相关的变量。 斜率无序：二分；横坐标无序：平衡树 四边形不等式：\(w_{i,j}+w_{i&#39;,j&#39;}\leq w_{i,j&#39;}+w_{i&#39;,j} \quad (i\leq i&#39;\leq j\leq j&#39;)\) 满足四边形不等式的式子具有转移单调性，可以采用栈维护转移集合。要确定一个式子满足决策单调，除了证明通常采用打表观察（不一定正确）。 有后效性的转移可以提前计算影响。]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-SAT总结]]></title>
    <url>%2Fsummary%2F2-sat%2F</url>
    <content type="text"><![CDATA[2-SAT（2-satisfiability）即给定一些布尔变量的或关系，判断是否有满足所有关系的变量取值。SAT问题是NPC问题，2-SAT问题是P问题。 ###构造2-SAT 考虑一个条件\(x\ \rm{or}\ y\)，则\(x=0 \Rightarrow y=1,y=0 \Rightarrow x=1\)。这两个推导都是单向而唯一的，因此我们可以把一个变量拆成两个点，并根据上述推导关系连边。具体而言，有向边\((u,v)\)的含义为：如果对\(u\)染色，则\(v\)也一定要被染色。 对这张关系图沿着边染色，则一组不同时染色一个变量的两种取值的图就是一个2-SAT解。下面给出DFS解2-SAT的代码，注意mark数组要开两倍。 12345678910111213141516171819202122232425262728293031struct TwoSat&#123; vector&lt;int&gt; a[N]; void AddClause(int x,bool valX,int y,bool valY)&#123; //x==valX||y==valY x=x*2+valX,y=y*2+valY; a[x^1].push_back(y); a[y^1].push_back(x); &#125; stack&lt;int&gt; s;bool mark[N]; bool DFS(int u)&#123; if(mark[u^1])return 0; if(mark[u])return 1; s.push(u);mark[u]=1; for(int i=0;i&lt;a[u].size();i++) if(!DFS(a[u][i]))return 0; return 1; &#125; bool Solve(int n)&#123; memset(mark,0,sizeof(mark)); for(int i=0;i&lt;n;i++) if(!mark[i]&amp;&amp;!mark[i^1]) if(!DFS(i))&#123; while(s.top()!=i)mark[s.top()]=0,s.pop(); mark[i]=0,s.pop(); if(!DFS(i^1))return 0; &#125; return 1; &#125;&#125;; 当一个变量两个取值都不能满足时，可以证明整个2-SAT问题无解，因此算法没有回溯，时间复杂度\(\mathrm{O}(n)\)。流程描述： 添加约束条件并加边； 对没有赋值的变量尝试赋为\(0\)： 成功。继续考察没有赋值的变量； 失败。退栈并取消标记，尝试赋为\(1\)： 成功。继续考察没有赋值的变量； 失败。该2-SAT问题无解。 注意到若\(x=0 \Leftrightarrow x=1\)，即一个变量的两个取值可以互相到达时无解，因此也可以通过Tarjan计算强联通分量\(\mathrm{O}(n)\)解决，但编程复杂度较高。 2-SAT少有独立出现，往往伴随着需要判定性的算法（如二分）。因此类似网络流，2-SAT的要点在于建图。 ###变量关系的构建 假设函数AddClause(valX,valY)构造了\(x=valX\ \mathrm{or}\ y=valY\)的语句，则： \(x=y\)：AddClause(0,1)，AddClause(1,0) \(x\not=y\)：AddClause(0,0)，AddClause(1,1) \(x=y=1\)：AddClause(0,1)，AddClause(1,0)，AddClause(1,1) \(x=y=0\)：AddClause(0,1)，AddClause(1,0)，AddClause(0,0) 还是很好理解的。后面两句的最后一个约束保证了它们的取值。有的时候某些变量的取值已经给定，这个时候事先染色就好了。 ###与二分图染色的区别 Refer from Sengxian's Blog。 二分图染色是双向推导，而2-SAT染色是单向推导。且二分图染色出现矛盾时会立刻跳出，而2-SAT会更换取值继续尝试。因此一般二分图染色不能解决2-SAT。 但有一种情况，是可以用二分图染色处理的，当且仅当所有条件是\(x=k\ \mathrm{or }\ y=k\)的形式。这个条件也可以写成\(\mathrm{not}(x\not=k\ \mathrm{and}\ y\not=k)\)，即\(x\not=k\)和\(y\not=k\)不能同时被选中，然后就可以在它们间连边进行二分图染色了。 ##练习 ###基础 ####JSOI2010 满汉全席 裸的2-SAT。需要一个hash表或map。 ####POJ3678 Katu Puzzle 根据要求对变量建图就好了。 ####POJ3207 Ikki's Story IV - Panda's Trick 题意：给一个圆和一些点，并在点之间连线。保证一个点最多被连一次，问所有线是否可能不相交。 两条连线的端点\((a,b),(c,d)\)如果有\((c-a)(b-c)(d-b)(a-d)&lt;0\)（即线段的端点各自在另一条线段分出的两个区间），则它们可能会相交。画个图发现当且仅当两条线的端点一内一外才不会相交。然后就可以建图了。 ####POJ3905 Perfect Election 题意：给定一些民众期待的选举人（\(2\)名）通过局面，问是否存在一种通过局面使得结果满足所有民众的期待。 题目条件只有或，直接上2-SAT。 ####POJ3683 Priest John's Busiest Day 题意：有一些新人要举行婚礼，每一对新人\(i\)的举行时间要么是\([st_i,st_i+d_i]\)，要么是\([ed_i-d,ed_i]\)。问能不能全部举行并给出方案。 不能一起举行的添加条件，接着跑2-SAT。 ##进阶 ####POJ2749 Building Roads 题意：有两个中转站，相互喜爱的牛的牛棚必须在同一个中转站，相互厌恶的牛的牛棚必须在不同中转站。最小化最远牛棚对距离。 二分答案，考察任意两对牛棚在两个中转站的\(4\)种情况是否在最大距离内并添加条件。对于有约束关系的牛棚也是如此。 ####UVA1391 Astronaut 训练指南练习题。然而我还没写，可以参考这里。 ####POJ3648 Wedding 题意：婚礼有\(n\)对新人要坐在一张长桌子上。同一对新人不能坐在同侧，有不可描述的关系（不限性别）的人不能同时坐在\(0\)号新娘对面。求坐在\(0\)号新娘一侧的人的一种可能性，或根本无解。 给每个人坐某一侧当作变量，新娘\(0\)所在侧为\(0\)，则同一对新人取值不等，有不可描述的人取值不能同时为\(1\)（至少有一个为\(0\)）。 ####高级 感觉2-SAT就没什么特别难的（暴言） ##总结 2-SAT可以求解一类抽象成变量取值的判定性问题，因此可以与二分之类的算法结合着用。往往题目提到分配成两份或有两个选择，基本上就跑不开2-SAT了。 2-SAT的DFS算法没有回溯过程； 2-SAT的条件添加： \(x=y\)：AddClause(0,1)，AddClause(1,0) \(x\not=y\)：AddClause(0,0)，AddClause(1,1) \(x=y=1\)：AddClause(0,1)，AddClause(1,0)，AddClause(1,1) \(x=y=0\)：AddClause(0,1)，AddClause(1,0)，AddClause(0,0) 好像真的没什么可以瞎扯的了]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论总结]]></title>
    <url>%2Fsummary%2Fnumber-theory%2F</url>
    <content type="text"><![CDATA[东西很分散，知识比较乱，因此就放在一起写了。 ##素性判断 ###Rabin-Miller 单次时间复杂度为\(\mathrm{O}(logn)\)的判素方法。当底数枚举范围为\((1,p]\)时，正确概率为\(1-\left(\frac 14\right)^p\)。OI中一般测试4~5次就足够了。原理是利用了费马小定理，具体的探究见Matrix67的素数与素性测试。 将待测试数\(x\)化为\(x-1=a*2^p\)的形式； 选择一个\([2.n)\)间的底数\(bas\)，对每个底数\(bas\)考察： 计算\(x&#39;=bas^{a*2^p}\bmod{x}\)； 分类讨论： \(x&#39;=1\)。令\(p&#39;=\frac p2\)，继续考察\(bas^{a*2^{p&#39;}}\pmod{x}\)； \(x&#39;=x-1\)。则\(x\)为\(bas\)下的伪素数，考察下一个底数; 否则\(x\)为合数，退出算法。 附上代码。 1234567891011121314151617181920bool RabinMiller(ll n)&#123; if(n==2)return 1; if(n&lt;=1||!(n&amp;1))return 0; int p=0;ll a; while((n-1)%(1&lt;&lt;(p+1))==0)p++; a=(n-1)/(1&lt;&lt;p); for(int i=1;i&lt;=UPP;i++)&#123; //UPP为测试次数 int bas=rand()%(n-2)+2; for(int j=p;j&gt;=0;j--)&#123; ll tmp=QPow(bas,a*((ll)1&lt;&lt;j),n); if(tmp==1)continue; else if(tmp==n-1)break; else return 0; &#125; &#125; return 1;&#125; 实际运用中还是很快的。 ###Eratosthenes筛法 NOIP知识点。直接放代码。 1234567void Eratosthenes()&#123; int upp=sqrt(N); for(int i=2;i&lt;=upp;++i) //大于sqrt(N)的数已经被筛过了 if(!notPri[i]) for(int j=i*i;j&lt;N;j+=i) //小于i^2的数已经被筛过了 notPri[j]=1;&#125; 值得注意的是我不止一次没注意筛法的上下界，使得复杂度变大。（其实也没有多慢） 线筛 ##欧拉函数 欧拉函数\(\Phi\)是积性函数，因此可以线性筛。 代码： void Phi(){ for(int i=1;i&lt;N;++i)phi[i]=i; for(int i=2;i&lt;N;++i) if(phi[i]==i) for(int j=i;j&lt;N;j+=i) phi[j]-=phi[j]/i; } 单个\(\Phi\)值只需要利用\(\Phi(n)=\Pi_{i=1}(1- \frac 1{p_i})\)即可。注意需要特判大于\(\sqrt{n}\)的因子。 int Phi(int x){ int ret=x，upp=int(sqrt(x)+1); for(int i=2;i&lt;=upp;++i) if(x%i==0){ ret-=ret/i; while(x%i==0)x/=i; } if(x&gt;1)ret-=ret/x; return ret; } ###指数循环节 考虑这么个式子：\(a^x\equiv c\pmod{p}\)。如果\(x\)很大就不能直接求了。 明显\(p\)为质数时，根据费马小定理有： \[ a^x \bmod{p} = a^{x \bmod \phi(p)} \bmod{p} \] 然而\(p\)是合数也有结论： \[ a^x \bmod{p} = a^{x \bmod \phi(p)+\phi(p)} \bmod{p}\quad (x\geq\phi(p)) \] 注意有条件，不能直接用（虽然通常可以）。 原根 待补 欧拉定理 待补 扩展欧拉定理 待补，但是其实上面给出式子了。 ##离散变换 和模运算有关。模运算除了除法外，四则运算都可以先模再运算最后模。除法需要找逆元。 ###逆元 \(x\)在\(p\)下存在逆元的充分必要条件是\((x,p)=1\)。 逆元的求法： 扩展欧几里得（求解\(a*inv+p*y=1\)） 费马小定理（\(a^{\Phi (p)}\equiv 1\pmod{p} \Rightarrow inv=a^{p-2}\ \text{（p为素数）}\)） 线性递推逆元表（\(inv_i=\left(p-\lfloor \frac pi \rfloor \right)* inv_{p\bmod{i}}\bmod{p}\)） 第三个很玄学就是了。简单证明帮助理解： 令\(p=nt+k\)，则： \[ \begin{aligned} nt+k&amp;\equiv 0\pmod{p} \\ \Rightarrow k&amp;\equiv -nt\pmod{p} \\ \Rightarrow n^{-1}&amp;\equiv -tk^{-1}\pmod{p} \\ \Rightarrow n^{-1}&amp;\equiv -\lfloor{\frac pn}\rfloor *(p\bmod{n})^{-1}\pmod{p} \end{aligned} \] 即\(inv_i=\left(p-\lfloor \frac pi \rfloor \right)* inv_{p\bmod{i}}\bmod{p}\)。 ###离散对数 其实就是求解\(a^x\equiv b \pmod{p}\)。根据费马小定理，对于\(p\)为质数的情况，\(i\)取\([0,p)\)时恰好使得\(a^i\bmod{p}\)取到\([0,p)\)的值各一次。因此此方程若有解，则一定在\([0,p)\)内有且仅有一解。 ####Baby-step Giant-step 求解这个方程的大步小步算法（Baby-step Giant-step）可以参考训练指南。这里只描述框架。 令\(m=\sqrt{p}\)，用哈希表或map记录取得\(a^i\bmod{p}\ (0\leq i&lt;m)\)时\(i\)的最小值； 对\(a^{j \times m}\ (1\leq j\leq m)\)查找表中是否存在\(b*a^{-m}\bmod{p}\)对应的\(i\)值： 存在。则最小解为\(x=j*m+i\)； 不存在。考察下一个j。 时间复杂度为\(\mathrm{O}(\sqrt{n})\)。然而使用BSGS的前提条件是\((a,p)=1\)，当\(p\)不是质数的时候不一定能使用（但是\(p\)为质数时必须有\(a&lt;p\)，否则也不保证\(a\)不为\(p\)的倍数）。好在我们可以使用扩展BSGS来解决\(p\)不是质数的情况。 1234567891011int BSGS(ll a,ll b,ll p)&#123; map&lt;ll,int&gt; s; int m=(int)ceil(sqrt(p)); ll tmp=1; for(int i=0;i&lt;m;i++,tmp=tmp*a%p) if(!s.count(tmp))s[tmp]=i; ll inv=Invert(tmp,p);tmp=b; for(int i=0;i&lt;m;i++,tmp=tmp*inv%p) if(s.count(tmp))return i*m+s[tmp]+1; return -1;&#125; ####扩展Baby-step Giant-step 我们不能求解的原因是费马定理不一定再适用，但可以通过不断对\(a\)和\(p\)提取GCD的方法使得\((a,p)=1\)，再应用BSGS。 明确这么一件事：令\(g=(a,p)\)，则\(a^x\equiv b\ \pmod{p} \Leftrightarrow \frac ag \times a^{x-1}\equiv \frac bg \pmod{\frac pg}\)，具体理由可以展开为不定方程后同除\(g\)即可。这样就可以通过不断除\((a,p)\)使得\((a,p)=1\)。流程： 当\(g=(a,p)\not =1\)，化方程为\((\frac ag) \times a^{x-1}\equiv \frac bg\ \pmod{\frac pg} \Rightarrow a^{x-1}\equiv \frac bg \times (\frac ag)^{-1}\ \pmod{\frac pg}\)； 若\(b\)已经为\(1\)，则\(x\)为除以\(g\)的次数（特判）； 否则操作直到\((a,p)=1\)； 使用BSGS。 注意特判是需要的，因为当\((a,p)\not =1\)时也有可能存在解\(x\)，而继续操作会使得\(x\)增大。 ###同余方程 即求解\(ax+by=c\)，也可以转化为\(ax\equiv c\ \pmod{b}\)。 ####扩展欧几里得 求解方法是扩展欧几里得，有解的充分必要条件是\((a,b)|c\)，求解的结果\(x_0,y_0\)是最小化\(|x|+|y|\)的一组解。由于比较模板，就直接放上代码了。 12345void ExtendGCD(int a,int b,int &amp;x,int &amp;y,int &amp;g) //x和y都是传引用&#123; if(!b)x=1,y=0,g=a; else ExtendGCD(b,a%b,y,x,g),y-=x*(a/b); //x和y要交换，a/b必须要向下取整&#125; 时间复杂度和欧几里得一样，可以近似看作\(\mathrm{O}(\log{n})\)。 求解的是\(ax+by=(a,b)\)的解。以下我们对变量带上\(&#39;\)符号时表示该值为原值除以\(g\)，则明显原问题的解为\(x=x_0 \times c&#39;,y=y_0 \times c&#39;\)。 要求出其他的解，则只需要迭代\(x=x_0+b&#39;,y=y_0-a&#39;\)即可。这个结论可以通过假设一组其他解\(x,y\)和\(x_0,y_0\)联立解得。我们往往要求\(x\)的最小非负解，根据这个结论我们可以得到\(x_+=(x_0\bmod{b&#39;}+b&#39;)\bmod{b&#39;c&#39;}\)。 ####欧几里得 既然都说了扩展欧几里得，还谈欧几里得做什么呢？我们观察式子： \[(a,b)=(b,a\bmod{b})\] 有\((a+b,b)=(b,a\bmod{b})=(a,b)\)，同理也可得\((a,a+b)=(a,b)\)。推广即： \[(a+b,a)=(a+b,b)=(a,b)=(a-b,a)=(a-b,b)\] 这个结论我也不知道有什么用，但是看起来可以化简一类累和GCD的问题。如SDOI2008 沙拉公主的困惑 处理了\((M! , i) = (M! + i , i) \ (1&lt;i \leq M!)\)，使得一个大数\(N!\ (N&gt;M)\)可以被分解成多段长度为\(M!\)的段，从而降低了求\(N!\)与\(M!\)中互质的二元组数的困难。 ####类欧几里得 震惊了，还有这种算法。等省选结束学习一发。 ###中国剩余定理 对于单组同余方程\(ax\equiv c\pmod{p}\)求解，我们可以使用扩展欧几里得。但对于多组同余方程\(x\equiv c_i\pmod{p_i}\)，我们需要中国剩余定理（Chinese Remainder Theorem）。 假设有\(n\)个方程组，且\(M=\prod p_i,m_i=\frac M{p_i}\)。我们考虑其中的一个方程\(x\equiv c_i\pmod{p_i}\)。由于\((m_i,p_i)=1\)，因此方程\(m_ix+p_iy=1\)有解。我们对这个方程两边同模\(p_i\)，并且令\(e_i=m_ix\)，则有\(e_i\equiv 1\pmod{p_i}\)。 根据一些神奇的方法构造出一个解\(x=\sum_{i=1}^n c_ie_i\)。观察这个式子，我们给两边同除\(p_i\)，则只剩下\(x\equiv c_ie_i \equiv c_i\pmod{p_i}\)，即原模方程组。然后就可以通过扩展欧几里得得到\(x\)的一个解了。 ####扩展中国剩余定理 用于解决不互质的情况。 假设任意两个方程组\(x\equiv c_1\pmod{p_1},x\equiv c_2\pmod{p_2}\)，化为方程组： \[ \begin{cases} x=c_1+k_1p_1 \\ x=c_2+k_2p_2 \\ \end{cases} \] 联立得\(c_1+k_1p_1=c_2+k_2p_2\)，可以解不定方程得到\(k_1,k_2\)的一组解\(k_1&#39;,k_2&#39;\)，因此\(k_1=k_1&#39;\frac{a_2-a_1}g+T\frac {p_2}g\)，\(T\)为任意整数。回代入任意一个\(x\)的方程得： \[ \begin{aligned} x=&amp;c_1+p_1k_1 \\ =&amp;c_1+p_1(k_1&#39;\frac{a_2-a_1}g+T\frac {p_2}g) \\ =&amp;c_1+p_1k_1&#39;(\frac{a_2-a_1}g+T\frac {p_1p_2}g) \end{aligned} \] 即$xc_1+p_1k_1'g \(，两个方程组合并为一个方程组。需要合并最多\)n-1\(个方程组，时间复杂度\)(n)\(。注意\)x$可能会很大，一般化为最小非负解再计算。 用这个方法也可以推出非扩展情况，然而非扩展情况的形式推不出扩展情况。 123456789101112131415161718ll ExtendCRT()&#123; ll a0,p0,a1,p1;bool flag=1; cin&gt;&gt;p0&gt;&gt;a0; for(int i=2;i&lt;=n;i++)&#123; ll x,y,g,c; cin&gt;&gt;p1&gt;&gt;a1; if(flag)&#123; ExtendGCD(p0,p1,x,y,g); c=a1-a0; if(c%g)&#123;flag=0;continue;&#125; x=x*(c/g)%(p1/g); a0+=x*p0;p0=p0*p1/g; a0%=p0; //防止溢出 &#125; &#125; if(flag)return (a0%p0+p0)%p0; else return -1;&#125; 这个代码可能是有问题的，在POJ过了，在BSOJ没过。然后我小叮当今天就要打爆你CRT的头 ##神奇小技巧 ###快速幂 NOIP内容。时间复杂度\(\mathrm{O}(\log{n})\)。 123456ll QPow(ll bas,ll t)&#123; ll ret=1; for(;t;t&gt;&gt;=1,bas=QMul(bas,bas)) if(t&amp;1)ret=QMul(ret,bas); return ret;&#125; ###快速乘 这个就比较少见了。当两个数的乘法（取模）可能连long long都爆时，就可以用这个方法。其思想是将十进制乘法变为二进制乘法，并按位计算。由于乘数\(b\)每次只会翻倍，因此不会超出long long。时间复杂度\(\mathrm{O}(\log{n})\)。 ll QMul(ll a,ll b){ if(a&gt;b)swap(a,b); ll ret=0; for(;b;b&gt;&gt;=1,(a&lt;&lt;=1)%=p) if(b&amp;1)(ret+=a)%=p; return ret; } ##练习 数论题目真是多而难写。很绝望。有些基础题真的水水的，就不放了。 ###Baby-step Giant-step ####SDOI2011 计算器 操作1为快速幂，操作2为同余方程，操作3为离散对数。 ####SDOI2013 随机数生成器 通过对递推式进行迭代可以得到离散对数的方程，需要扩展BSGS。但是题目需要多个分类讨论，比较复杂。 ###同余方程 ####NOI2002 荒岛野人 假设\(M\)个洞穴两个野人\(t\)天相遇，则有\(pos_i+t \times det_i=pos_j+t \times det_j \pmod{M}\)，可以解不定方程。如果不相遇，则\(t\)应该大于两个野人寿命最小的那个，或者根本无解。 从小到大枚举\(M\)，对每个\(M\)对任意两个野人判定是否可行即可。时间复杂度\(\mathrm{O}(MN^2)\)，事实上到不了上界。 ###欧拉函数 ####SDOI2008 沙拉公主的困惑 由于辗转相除法\((a+b,b)=(a,b)\)，因此\((M!,i)=(M!+i,i)\)，即对于\([1,N!]\)的每一段\(M!\)，与\(M!\)互质的个数都是一样的。我们知道与\(M!\)互质的个数为\(\phi(M!)\)，因此答案\(ans={N!*\phi(M!) \over M!}\)。 展开欧拉函数得： \[ans=N!*\Pi_{i=1} (1-\frac1{p_i}) \quad (p_i|M!\text{且}p_i\text{为质数})\] 不难发现\(p_i\)其实就是\([1,m]\)的所有质数，因此我们可以预处理出小于\(n\)的质数的\((i-1)\over i\)的积和\(n!\)，就可以\(\mathrm{O}(1)\)回答询问了。 总时间复杂度\(\mathrm{O}(max(n,m))\)。 ###快速乘/快速幂 ####BZOJ4766 文艺计算姬 根据矩阵树定理可以推得答案为\(n^{m-1}*m^{n-1}\)，需要快速乘和快速幂。 也可以用prufer序列得到。 ##总结 数论是很神奇的东西，数论题是奥妙重重的题目。入手点一般在于将题目抽象为目标式、将目标式化简为高效可求式的过程。为此必须熟练掌握初等数论的内容特别是结论，以应对其中的数学变换。 当然猜测不出规律的时候可以打表观测说不定就猜对了。 （然后没有具体的总结，毕竟数论变化太多，需要结合题目看）]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[置换群总结]]></title>
    <url>%2Fsummary%2Fpermutation-group%2F</url>
    <content type="text"><![CDATA[群及置换群的定义略去，此处我们重点讨论其性质。 置换群的元素是置换，置换的运算是连接。比如： \[ \left( \begin{matrix} 1 &amp;2 &amp;3\\ 2 &amp;1 &amp;3\\ \end{matrix} \right) \left( \begin{matrix} 1 &amp;2 &amp;3\\ 1 &amp;3 &amp;2\\ \end{matrix} \right) = \left( \begin{matrix} 1 &amp;2 &amp;3\\ 3 &amp;1 &amp;2\\ \end{matrix} \right) \] 三个置换可以表示为\((1\ 2)(3),(1)(2\ 3),(1\ 3\ 2)\)。 ##理论基础 ###Burnside引理 设\(G\)是\(N=\{1,2,\cdots,n\}\)上的置换群，\(G\)是\(N\)上可引出不同的等价类，其中不同的等价类的个数为： \[\frac1{|G|} \Sigma_{g\in G} f(g)\] 其中\(f(g)\)为在置换\(g\)的连接下不变元的个数。 注意对\(\forall\ i,j\in G,i\cdot j\in G\)。因此假设置换集有旋转\(90^\circ\)，则旋转\(180^\circ\)也要在置换集中。特别注意如果定义了自己等价于自己，则置换元也要在集合中。 这帮助我们解决了等价类计数问题，但是当规模变大时，我们不可能枚举所有元素考察是否在置换下不变。因此有时会用到组合数学或动态规划的方法进行计数，同时还需要Polya定理。 ###polya定理 设\(G=a_1,a_2,\dots,a_n\)是\(n\)个对象的置换群，用\(m\)种颜色（不一定都用上）给这\(n\)个对象着色，则不同的着色方案数为： \[\frac1{|G|} \Sigma_{g\in G} m^{f(g)}\] 其中\(f(g)\)为置换\(g\)的循环节数。 可以理解为只有每个循环都染一种颜色，置换后才会不动。则不动点自然为\(m\)的循环节数次幂。这极大加快了我们计算染色等价类的速度，在一些特殊等价类（如循环同构）中甚至可以不需要真正计算循环节而采用结论。 不加证明地给出如下结论： 在长度为\(n\)的循环同构中，对移动\(i\)个元素的置换\(g_i\)有\(f(g_i)=(n,i)\)，每个循环长度\(len_i=\frac n{(n,i)}\)。 可以画个圆理解。有了这个结论，我们就可以化简循环同构类染色的计数。其他的等价类也有结论，但是往往比较少见，需要现推。 通常步骤： 列出所有置换。 利用Burnside引理和Polya定理计算每个置换的不变点。 最后除以置换总数。 有时候在第二步呆太久会忘记最后一步，因此要小心。 ##练习 等价类计数题目基本套公式，但更重要的通常在于如何快速计算置换中的不变点。 ###基础 ####POJ1286 Necklace of Beads 基础题目。等价类具有特殊性，可以得到结论，不需要真正计算循环节数。 ###进阶 ####POJ2154 Color 循环同构，直接结论。显然答案为\(\frac 1n\Sigma_{i=1}^n n^{(i,n)}\)，然而\(n\)很大，需要优化。我们单独考察指数部分。令\(j=(i,n)\)，有： \[ \begin{align} \frac 1n\Sigma_{i=1}^n n^{(i,n)} &amp;=\frac 1n\Sigma_{i=1}^n \Sigma_{j|(i,n)} n^j \text{且}[(i/j,n/j)==1] \\ &amp;=\frac 1n\Sigma_{j|n} \Sigma_{i=1}^{n/j} n^j \text{且}[(i/j,n/j)==1] \\ &amp;=\frac 1n\Sigma_{j|n} \phi (n/j)*n^j \\ \end{align} \] 需要质数表、快速幂和单欧拉函数值计算，但时间复杂度远远到不了\(\mathrm{O}(n)\)。然而我们最后要除以\(n\)，模数不保证质数，也不一定有逆元。我们发现答案的每一项都存在\(n\)的非\(0\)次幂，因此我们在快速幂的时候就可以少乘一个\(n\)。 ####HNOI2008 洗牌 保证任意几种洗牌法可以用其中的一种代替，且都能回到原状态保证了置换群的封闭性，可以用Burnside引理。不使用Polya定理是因为有颜色数量的限制，不能直接使用。 我们发现一个循环要不变就只能染同一种颜色，因此求出一种置换的循环后，我们相当于求对这些循环染\(3\)种颜色使得总数满足数量限制的方案数。这是一个背包问题，可以动态规划解决。 ####POJ2888 Magic Bracelet 类似POJ2154 Color，但是这次有颜色限制，然而我们发现颜色数量很少。 考虑一个置换\(g\_i\)，它有\((n,i)\)个循环长度为\(\frac{n}{(n,i)}\)的循环，并且这些循环在任意长度为\((n,i)\)的序列中刚好各有一个循环元素，整个序列为这段序列重复\(\frac{n}{(n,i)}\)次构成（画图），因此我们可以认为这段序列首尾相接的满足方案数是等价的。把珠子看成点，能连接的两个珠子之间连边，则满足的方案相当于从点\(u\)经过\((n,i)\)个点再回到\(u\)的方案数。令邻接矩阵为\(a\)，则方案数为\((a^{(n,i)})_{u,u}\)（邻接矩阵的性质）。 同样利用欧拉函数加速计算，本题解决。 ###高级 ####Sgu282 Isomorphism/SHOI2006 有色图 是道好题。 题目很明显是Polya定理计数，不过我们计数的对象不是点而是边，这就不容易计算循环节了。不过我们发现对于完全图，一个边由唯一确定的两个点确定，因此点的一种置换唯一对应边的一种置换，即置换数\(|G|=n!\)。对于一个边，它的置换是由两个点的置换决定，边循环是点循环上一圈长度任意的连续的边集（想象一个点循环上有一条边连接了任意两个点，则一次点置换之后，边会顺着置换方向移动\(1\)格，而此处在置换前的边，在置换后又对应了下一个间隔为\(1\)的边，直到最终回到初始边）。因此我们希望通过考虑点的置换间接得到边的置换节，从而得到Polya定理中的指数。 不难发现一个边的两个点有两种情况：在点循环中，在点循环间。我们先确定这么一个结论：边循环节\(=\)点循环中的边循环节\(+\)点循环间的边循环节。分类讨论： 在点循环中。则按照刚刚我们的脑补，一个边循环由转了一圈循环长度为\(len\)的点循环的边集构成，因此边循环长度为\(len\)。然而我们发现\(len\)为偶数的情况时长度不一定都是\(len\)，比如边的长度刚好为\(\frac{len}2\)时，转\(\frac{len}2\)次就结束了（画图验证）。显然奇数情况不会出现长度为\(\frac{len}2\)的边。我们再分奇偶讨论： \(len\)为奇数。则在点循环中只有\(\frac{len*(len-1)}2\)条边，每个边循环长度都为\(len\)，因此循环节数为\(\frac{len-1}2=\lfloor \frac{len}2 \rfloor\)。 \(len\)为偶数。则恰好只有一个循环长度为\(\frac{len}2\)，因此我们从\(\frac{len*(len-1)}2\)条边中去除多余的\(\frac{len}2\)条边，再给循环节数单独加上\(1\)。循环节数为\(\frac{len}2\)。 合并结果为\(\frac{len}2\)。 在点循环间。则对于一条边，相当于在两个点循环\(len_i\)与\(len_j\)中连边，每次轮换就前进\(1\)格。不难看出这样的循环长度为\([len_i,len_j]\)，且所有的循环不相交。因此循环节为\(\frac{len_i*len_j}{[len_i,len_j]} = (len_i,len_j)\)。 综上，我们得到了对于给定的一种点循环长度方案计算边循环节长度的算法，且满足\(\Sigma{len_i}=n\)。这个就是整数划分方案，对于\(n\leq 53\)来说数量远少于\(n!\)，可以DFS枚举。令\(cnt_i\)为划分中\(i\)出现的次数，\(len_i\)为划分的一个方案集，则满足这种划分的排列数为\(\frac{n!}{\Pi(cnt_i!)\Pi{len_i}}\)，简单证明： 考虑划分方案。假设一种划分方案已经被我们钦定排成一排，对于每种全排列我们都顺序按划分方案划分，不难看出这种划分方案在考虑划分间及其内部的顺序时是不重复也不遗漏的，这样的方案数为\(n!\)。 不考虑划分集内部元素。我们认为集合大小相同的两个集合是等价的，因此总数为可重集的全排列，要除以\(\Pi(cnt_i!)\)。 考虑划分集内元素。由于划分集内是一个循环，因此我们认为循环同构是等价的。而对于不产生循环同构的含有\(len\)个元素的序列，我们每对一个排列进行循环同构就能增加\(len-1\)个新排列（注意所有产生的序列和原序列都不相同，否则原序列存在循环同构），因此每一个划分集要除以\(len\)，总数要除以\(\Pi{len_i}\)。 综上，满足一种划分条件且划分集内部不存在循环同构的全排列数为\(\frac{n!}{\Pi(cnt_i!)\Pi{len_i}}\)。 于是我们就很完美地解决了这个问题。 ##总结 置换群通常解决一类置换问题，Burnside引理和Polya定理通常解决一类等价类计数问题。等价类计数的重点在于寻找不变点总数，通常存在高效的方法。有时需要动态规划和数论知识甚至矩阵快速幂解决。 Burnside引理：求解每个置换下本质不同的方案数即在该置换下保持不变的方案数；Polya定理：计算每个置换下循环节个数。 染色计数中，若存在对染色的限制（数量、间隔）则不能直接应用Polya定理。Polya定理的本质是对置换的每个循环染同一种颜色。 无论用Burnside引理还是Polya定理，都需要除以置换总数。若存在与总数不互质的模数，需要考虑边做就边除以总数。]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>置换群</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演总结]]></title>
    <url>%2Fsummary%2Fmobius-inversion%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演是偏序集上的一个反演，不过在此处我们只讨论整数格上的莫比乌斯反演。 整数格上的莫比乌斯反演 定义\(\mu\)函数： \[ \mu(n)= \begin{cases} 1,&amp;n=1 \\ (-1)^m,&amp;n=\Pi_{i=1}^m p_i^{k_i},\Pi_{i=1}^m k_i=1 \\ 0,&amp;otherwise\\ \end{cases} \] 函数有两个性质。 \(\mu\)是积性函数。 \(\Sigma_{i=1}^n\mu(i)= \begin{cases} 1,&amp;n=1 \\ 0,&amp;othewise\\ \end{cases}\) 第一条性质说明\(\mu\)可以线性筛；第二条性质提供了我们一个当且仅当\(n=1\)时计数的函数，因此在遇到求\((i,j)=1\)的问题中通常会用到它。 直接给出代码。 1234567891011void Init()&#123; mu[1]=1; for(int i=2;i&lt;N;i++)&#123; if(!notPri[i])pri[siz++]=i,mu[i]=-1; for(int j=0;j&lt;siz&amp;&amp;i*pri[j]&lt;N;j++)&#123; int nxt=i*pri[j];notPri[nxt]=1; if(i%pri[j])mu[nxt]=-mu[i]; else &#123;mu[nxt]=0;break;&#125; &#125; &#125;&#125; 当出现平方因子就退出筛法保证了每个数只会被最小的因子筛去，因此时间复杂度线性。\(\mu_i=0\)的情况是由最小因子筛掉的，而其他情况都是由\(\mu_i=-\mu_j\)得到的。 反演 想学习很多反演，但是太菜了只会这个.jpg 以后可能会补吧。 若函数\(f(n),g(n)\)为数论函数，且满足\(f(n)=\Sigma_{i|n}g(i)\)，则有： \[g(n)=\Sigma_{i|n}f(n)\mu(\frac ni)=\Sigma_{i|n}f(\frac ni)\mu(i)\] 若函数\(f(n),g(n)\)为数论函数，且满足\(f(i)=\Sigma_{d=1}^{\lfloor \frac ni \rfloor}g(i*d)\)，则有： \[g(i)=\Sigma_{d=1}^{\lfloor \frac ni \rfloor}f(i*d)\mu(d)\] 证明略去。事实上两种方法都可以比较方便地运用，一般第一种不需要构造函数，而第二种需要构造函数。 常用反演 定义符号$[exp]= \[\begin{cases} 1,&amp;exp=true\\ 0,&amp;exp=false \\ \end{cases}\] $。 定义函数\(e(n)=[n==1],id(n)=n\)，则有： \[ e=\mu \times 1 \\ id=\phi \times 1 \] 乘法代表狄利克里卷积。因此反演也可以表示为： \[f=g \times 1 \Leftrightarrow g=f \times \mu\] 应用 二维GCD计数前缀和 求\(\Sigma_{i=1}^n \Sigma_{j=1}^m [(i,j)==k]\)且\(n\leq m\)。 不使用函数变换的方法 不难发现： \[ \begin{aligned} \Sigma_{i=1}^n \Sigma_{j=1}^m [(i,j)==k] =&amp;\Sigma_{i=1}^n \Sigma_{j=1}^m [(\frac ik,\frac jk)==1] \\ =&amp;\Sigma_{i=1}^n \Sigma_{j=1}^m e((\frac ik,\frac jk)) \\ =&amp;\Sigma_{i=1}^n \Sigma_{j=1}^m \Sigma_{g|(i,j)} \mu(g) \\ =&amp;\Sigma_{i=1}^n \Sigma_{j=1}^m \Sigma_{g|i\text{且}g|j} \mu(g) \\ =&amp; \Sigma_{g=1}^n\Sigma_{i=1}^{\lfloor \frac ng\rfloor} \Sigma_{j=1}^{\lfloor \frac mg\rfloor} \mu(g) \\ =&amp; \Sigma_{g=1}^n \mu(g) \Sigma_{i=1}^{\lfloor \frac ng\rfloor} \Sigma_{j=1}^{\lfloor \frac mg\rfloor} \\ \end{aligned} \] 而\(\lfloor \frac ng\rfloor\)只有不超过\(\sqrt{n}\)种取值，\(\lfloor \frac ng\rfloor\)和\(\lfloor \frac mg\rfloor\)只有不超过\(\sqrt{n}+\sqrt{m}\)种取值，因此可以将\([1,n]\)分成\(\sqrt{n}+\sqrt{m}\)块，每一块的\(\lfloor \frac ng\rfloor\)和\(\lfloor \frac mg\rfloor\)取值都不变，则我们预处理\(\mu\)后可以对一块区间进行\(\mathrm{O}(1)\)的统计，总时间复杂度为\(\mathrm{O}(\sqrt{n}+\sqrt{m})\)。 使用函数变换的方法 令\(f(k)=\Sigma\_{i=1}^n \Sigma_{j=1}^m [(i,j)==k]\)，\(g(k)=\Sigma_{i=1}^n \Sigma_{j=1}^m [k|(i,j)]\)，则\(f(k)\)就是我们要求的答案。很明显\(k|(i,j) \Leftrightarrow k|i\text{且}k|j\)，因此\(g(k)=\lfloor \frac nk \rfloor \lfloor \frac mk \rfloor\)。 发现\(g(k)=\Sigma_{d=1}^{\lfloor \frac nk\rfloor}f(d*k)\)，因此有： \[ \begin{aligned} f(k)=&amp;\Sigma_{d=1}^{\lfloor \frac nk \rfloor}g(d*k)\mu(d) \\ =&amp;\Sigma_{d=1}^{\lfloor \frac nk \rfloor}\left\lfloor \frac n{dk} \right\rfloor \left\lfloor \frac m{dk} \right\rfloor\mu(d) \end{aligned} \] 令\(n&#39;=\lfloor \frac nk \rfloor,m&#39;=\lfloor \frac mk \rfloor\)，则 \[ \begin{aligned} f(k)=&amp;\Sigma_{d=1}^{\lfloor \frac nk \rfloor}\left\lfloor \frac {n&#39;}d \right\rfloor \left\lfloor \frac {m&#39;}d \right\rfloor\mu(d) \end{aligned} \] 类似上面可以证明\(n&#39;,m&#39;\)的取值个数，因此求解也是\(\mathrm{O}(\sqrt{n}+\sqrt{m})\)的。 好了，那求了一个区间后，怎么寻找下一个区间？假设我们当前区间开头为\(i\)，并假设下一个区间为\(j\)，则： \[ \begin{aligned} \left\lfloor \frac {n&#39;}i \right\rfloor &amp;\leq \left\lfloor \frac {n&#39;}j \right\rfloor \\ \Rightarrow \left\lfloor \frac {n&#39;}i \right\rfloor &amp;\leq \frac {n&#39;}j \\ \Rightarrow j &amp;\leq \frac {n&#39;}{\lfloor \frac {n&#39;}i \rfloor} \\ \Rightarrow j &amp;\leq \left\lfloor \frac {n&#39;}{\lfloor \frac {n&#39;}i \rfloor}\right\rfloor\\ \end{aligned} \] 同理可得\(m\)。因此\(j=min( \left\lfloor \frac {n&#39;}{\lfloor \frac {n&#39;}i \rfloor} \right\rfloor,\left\lfloor \frac {m&#39;}{\lfloor \frac {m&#39;}i \rfloor} \right\rfloor)\)。这个技巧在很多莫比乌斯反演的题目都用得上。 求约数个数和 直接给出结论： 若\(d(n)\)为\(n\)的约数个数，则有： \[ d(nm)=\Sigma_{i|n} \Sigma_{j|m} [(i,j)==1] \] 证明不略。假设\(nm=\Pi\_{i=1}p_i^{x_i},n=\Pi_{i=1}p_i^{y_i}\)，则\(m=\Pi_{i=1}p_i^{x_i-y_i}\)。 对于\((i,j)=1\)，考虑因子\(p_k\)，则\(i\)和\(j\)的\(p_k\)项指数不能都不为\(0\)。当\(i\)的\(p_k\)为\(0\)时，\(j\)有\(x_k-y_k+1\)种取值；当\(j\)的\(p_k\)为\(0\)时，\(i\)有\(y_k+1\)种取值；\(i,j\)的\(p_k\)项可以都取\(0\)。因此\(i\)与\(j\)的\(p_k\)项有\(x_k+1\)种二元组\((i,j)\)的取值，总二元组方案数为\(\Pi_{i=1} x_i+1\)，满足约数个数公式。 然后还有个推广的神奇大结论： \[\sum_{x_1}^{y_1} \sum_{x_2}^{y_2} \cdots \sum_{x_k}^{y_k} d(x_1 x_2 \cdots x_k) = \sum_{x_1}^{y_1} \sum_{x_2}^{y_2} \cdots \sum_{x_k}^{y_k} \prod_{i=1}^{k} \left \lfloor \frac{y_i}{x_i} \right \rfloor \prod_{i &lt; j } [(x_i, x_j)=1]\] 太神奇，证明需要二重数学归纳，略过。 杜教筛 高端，不会。 min-25筛 高端，不会。 练习 莫比乌斯的题目通常能转化为\((i,j)=1\)的计数问题，而转化为计数问题我们就容易通过分块求解了。 基础 POI2007 Zap 二维GCD计数前缀和。 HAOI2011 Problem b POI2007 Zap的加强版，容斥原理加加减减就好了。 BZOJ2820 YY的GCD 仍然是二维GCD计数前缀和，不过需要\((i,j)\)为质数。只要预处理质数的\(\mu\)前缀和就好了。 SDOI2008 仪仗队 不被挡住即行列\((i,j)=1\)（从\(0\)标号），因此答案为\((\Sigma\_{i=1}^n \Sigma\_{i=1}^n [(i,j)==1])+2\)（\(2\)个是\((0,1),(1,0)\)）。最终化为\((\Sigma\_{g=1}^n \mu(g)\lfloor \frac ng\rfloor ^2)+2\)，分块求解。 进阶 SDOI2015 约数个数和 是道好题，然而需要结论。 令\(n&#39;=\frac ng,m&#39;=\frac mg\)，则 \[ \begin{aligned} \Sigma_{i=1}^n \Sigma_{j=1}^m d(ij) =&amp;\Sigma_{i=1}^n \Sigma_{j=1}^m [(i,j)==1] \\ =&amp;\Sigma_{i=1}^n \Sigma_{j=1}^m {\lfloor \frac ni\rfloor}{\lfloor \frac mj\rfloor} \Sigma_{g|(i,j)}\mu(g) \\ =&amp;\Sigma_{g=1}^n\mu(g)\Sigma_{i=1}^{\lfloor \frac ng\rfloor} \Sigma_{j=1}^{\lfloor \frac mg\rfloor} \frac n{ig} \frac m{jg} \\ =&amp;\Sigma_{g=1}^n\mu(g)\Sigma_{i=1}^{n&#39;} \Sigma_{j=1}^{m&#39;} \frac {n&#39;}i \frac{m&#39;}j \\ =&amp;\Sigma_{g=1}^n\mu(g)\Sigma_{i=1}^{n&#39;} \frac {n&#39;}i\Sigma_{j=1}^{m&#39;} \frac{m&#39;}j \\ \end{aligned} \] 然后就可以预处理\(f(n)=\Sigma\_{i=1}^n \frac ni​\)的值，每次询问就可以分块解决。之所以要预处理\(f(n)​\)，是因为在倒数第二步时如果采用直接计算\(\Sigma\_{i=1}^{n&#39;} \Sigma\_{j=1}^{m&#39;} \frac {n&#39;}i \frac{m&#39;}j​\)开销是很大的。但如果我们能预处理，就能做到\(\mathrm{O}(1)​\)计算。 预处理时间复杂度\(\mathrm{O}(n\sqrt{n})\)，单次询问时间复杂度\(\mathrm{O}(\sqrt{n})\)。 HNMTC2015#5 Lucas的数论 发现是SDOI2015 约数个数和的单询问加强版本，上面对\(\mu\)前缀和的\(\mathrm{O}(n)\)时间复杂度已经不能满足我们了。 式子最终可以推成这样： \[\Sigma_{g=1}^n\mu(g) d(n&#39;)^2 \] 单次\(f(n&#39;)\)可以分块求。假设我们预处理好了μ的前缀和，时间复杂度就是\(\mathrm{O}(\sqrt{n})\)的。这里就有个求\(μ\)的前缀和\(sum\)的奇技淫巧了： \[sum(n)=1-\Sigma_{i=2}^n sum(\lfloor \frac ni \rfloor)\] 递归求解。注意这也是能分块的，因此一层的时间为\(\mathrm{O}(\sqrt{n})\)，据说没有记忆化搜索时计算一次的时间复杂度为\(\mathrm{O}(n^{\frac 23})\)。不过事实上我们可以记忆化搜索，或者线筛预处理出\(n\leq 5000000\)（测试得到这个效率比较高）的\(\mu\)前缀和减少计算。 总时间复杂度未知，不过测试极限数据还是挺极限的。 高级 没做过什么高级的。 总结 莫比乌斯反演基本上离不开GCD和两个累和符号，而且重点往往是把式子化成统计GCD=1个数的形式，并反演求解。求解一般通过分块和预处理\(\mu\)前缀和的方式\(\mathrm{O}(\sqrt{n})\)求和。 \(e=\mu \times 1,id=\phi \times 1\) \(\mu\)函数的性质： \(\mu\)是积性函数。 $_{i=1}^n(i)= \[\begin{cases} 1,&amp;n=1 \\ 0,&amp;othewise\\ \end{cases}\] $ \(\mu\)的神奇前缀和计算：\(sum(n)=1-\Sigma_{i=2}^n sum(\lfloor \frac ni \rfloor)\) 当待分块函数（如\(\mu\)）可以单独提出预处理时，可以通过此降低时间复杂度。 若多次询问中，分块区域下含有GCD的枚举值\(g\)和\(i\)或\(j\)之一，可以通过枚举\(ig\)或\(jg\)，再枚举\(g\)加速。（说法很意识流，详见莫比乌斯反演简要笔记 - GCD的幂） 积性函数有时不好证明，可以打表观察。重点观察幂和质数的值。]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡树总结]]></title>
    <url>%2Fsummary%2Ftreap%2F</url>
    <content type="text"><![CDATA[二叉搜索树（Binary Search Tree）是一种二叉树数据结构，其维护了一个支持快速检索的集合。 BST 有很多，如 Treap，Splay，红黑树，Size-Balanced Tree，但是此处我们只讨论 Treap。 Treap Treap的节点具有一个\(val\)值和\(key\)值，\(val\)值维护这个集合，\(key\)值维护了Treap的平衡。光看\(val\)值，Treap的中序遍历构成一个递增序列；光看\(key\)值，Treap是一个堆（方便起见，我们默认为小根堆）。其通过旋转来维护形态，影响其形态的因素之一是\(key\)。因此\(key\)一般用随机值，可以证明这样的Treap期望高度为\(\mathrm{O}( \log n )\)。 基本操作 Treap支持5种基本操作： 插入\(\mathrm{O}( \log n )\) 删除\(\mathrm{O}( \log n )\) 询问某数排名\(\mathrm{O}( \log n )\) 询问排名为k的数\(\mathrm{O}( \log n )\) 查找某数及其前驱后继\(\mathrm{O}( \log n )\) 为了方便基本操作，我们定义Treap节点如下： 12345678910111213141516171819202122struct Node&#123; int v,r,s,n; Node *ch[2]; Node(int _v,int _r=rand())&#123; v=_v;r=_r;n=1; ch[0]=ch[1]=NULL; &#125; inline int Cmp(int x)&#123; if(x==v)return -1; else return x&gt;v; &#125; inline int Size()&#123; return this==NULL?0:s; &#125; inline void Maintain()&#123; s=n+ch[0]-&gt;Size()+ch[1]-&gt;Size(); &#125;&#125;; 定义 Treap 如下： 123Treap&#123; Node *rt=NULL;&#125;; 旋转 画个图就不难想象这个过程。o 节点必须用引用而不是指针，因为最后的过程需要把 o 指向 t 所在节点，而非单纯复制t节点的信息。 1234567void Rotate(Node *&amp;o,int d)&#123; Node *t=o-&gt;ch[d^1]; o-&gt;ch[d^1]=t-&gt;ch[d]; t-&gt;ch[d]=o; o-&gt;Maintain();t-&gt;Maintain(); o=t;&#125; 插入 根据 Treap 的中序遍历性质，递归节点找到对应位置插入即可。新节点可能会破坏 Treap 的堆性质，因此需要旋转。如果该节点已被创建，则增加数量。注意需要维护！ 123456789101112void Insert(Node *&amp;o,int v)&#123; if(o==NULL)o=new Node(v); else&#123; int d=o-&gt;Cmp(v); if(d==-1)(o-&gt;n)++; else&#123; Insert(o-&gt;ch[d],v); if(o-&gt;ch[d]-&gt;r &lt; o-&gt;r)Rotate(o,d^1); &#125; &#125; o-&gt;Maintain();&#125; 删除 根据 Treap 的中序遍历性质，递归节点找到对应位置删除即可。同样为了维护堆性质，如果删除之后会破坏，则把要删除的节点旋转到儿子节点（此时两个儿子较小的一个被旋转到当前位置）再递归删除即可。如果非空则需要维护。 12345678910111213141516void Delete(Node *&amp;o,int v)&#123; int d=o-&gt;Cmp(v); if(d==-1)&#123; if(o-&gt;n&gt;1)(o-&gt;n)--; else&#123; if(o-&gt;ch[0]==NULL)o=o-&gt;ch[1]; else if(o-&gt;ch[1]==NULL)o=o-&gt;ch[0]; else&#123; int d2=o-&gt;ch[0]-&gt;r &lt; o-&gt;ch[1]-&gt;r; Rotate(o,d2); Delete(o-&gt;ch[d2],v); &#125; &#125; &#125;else Delete(o-&gt;ch[d],v); if(o!=NULL)o-&gt;Maintain();&#125; 询问某数排名 根据中序遍历性质，这是一个很容易思考的递归过程。 1234567int Rank(Node *o,int v)&#123; if(o==NULL)return 0; int d=o-&gt;Cmp(v),l=o-&gt;ch[1]-&gt;Size(); if(d==0)return Rank(o-&gt;ch[0],v); else if(d==-1)return l; else return l+o-&gt;n+Rank(o-&gt;ch[1],v);&#125; 注意上面的代码返回值是小于某数的个数而非该数的排名，这是为了方便查找不存在于集合的数。如果要变成集合中的数需要对排名\(+ 1\)。 询问排名为k的数 同样是递归过程。 1234567int Kth(Node *o,int k)&#123; if(k&gt;o-&gt;s)return -1; int l=o-&gt;ch[0]-&gt;Size(),n=o-&gt;n; if(k&lt;=l)return Kth(o-&gt;ch[0],k); else if(k&lt;=l+n)return o-&gt;v; else return Kth(o-&gt;ch[1],k-l-n);&#125; 查找 不难实现。$d = 0 $时寻找前驱，否则寻找后继。注意写的时候要特别注意寻找前驱时是向大数移动更新，寻找后继的时候是向小数移动更新。 12345678int Find(int v,int d)&#123; Node *o=rt; int ret=d?INF:-INF; while(o!=NULL) if(d?v&lt;o-&gt;v:v&gt;o-&gt;v)ret=o-&gt;v,o=o-&gt;ch[d^1]; else o=o-&gt;ch[d]; return ret;&#125; 扩展操作 启发式合并两棵 Treap\(\mathrm{O}( n \log ( m / n ) )\) 所谓启发式合并，就是把较小的 Treap 节点一个个暴力拆掉插入到较大的 Treap 中。如果较小的有\(n\)个节点，较大的有\(m\)个节点，则可以证明时间复杂度为\(\mathrm{O}( n \log ( m / n ) )\)。如果是相对有序，则可以用非旋转式 Treap 维护。相对有序是指较小 Treap 的最大值小于较大 Treap 的最小值，这样只需要首尾相接。 非旋转式 Treap 非旋转 Treap 拥有 Treap 的中序遍历相对有序特性与堆特性，但是不能旋转。由于非旋转式 Treap 不需要旋转，因此能较好地维护节点的父子关系，也可以做到可持久化。 基本操作 建树\(\mathrm{O}( n )\) 合并\(\mathrm{O}( \log n )\) 分裂\(\mathrm{O}( \log n )\) 虽然基本操作少，但是一起用却可以做很多事情。 构建 Treap 与笛卡尔树是一样的，因此我们可以以笛卡尔树的线性建树方法建 Treap。 考虑一个已经相对有序的序列（可以是一个递增/递减数列，也可以是一段固定的字符串，Treap的中序遍历维护的正是这些），对于节点$i ( val , key ) $，有： 倒序寻找第一个\(j &lt; i\)使得\(key_j &lt; key_i\) 将\(i\)的左子树设为\(j\)，将\(j - 1\)的右子树设为\(i\) 这可以用栈维护。每个节点只会进出栈一次，因此时间复杂度是线性的。可以这么考虑：栈维护了当前的树的最右链，我们正打算插入节点\(i\)。但是插入节点\(i\)之后可能会破坏堆性质，需要手动\(key\)值大于\(i\)的\(key\)值的树挂在\(i\)的左子树来维持小根堆形态，同时又不破坏中序遍历。最后需要把摘下来的子树的父亲节点重设右子树为\(i\)。实际中为了方便，会添加一个 \(val\)和\(key\)都为\(\infty\)的虚拟节点来方便建树。 注意每个节点在出栈之后都不会再被修改儿子，因此我们需要在出栈之后维护该节点。 123456789101112131415161718192021void Build(int n)&#123; stack&lt;Node*&gt; s; rt=new Node(-INF,-INF); s.push(rt); for(int i=1;i&lt;=n;i++)&#123; Node *o=new Node(i); while(s.top()-&gt;r &gt; o-&gt;r)&#123; o-&gt;ch[0]=s.top(); s.top()-&gt;Maintain(); s.pop(); &#125; s.top()-&gt;ch[1]=o; s.push(o); &#125; while(!s.empty())&#123; s.top()-&gt;Maintain(); s.pop(); &#125; rt=rt-&gt;ch[1]; &#125; 合并 类似于斜堆，非旋转式 Treap 的合并是一个递归过程。合并的时候需要保证两个 Treap 已经相对有序，只需要中序遍历首尾相接。但是由于不可旋转，因此它不能像斜堆合并一样转来转去，需要特判。流程如下： 两棵树有一棵为空，则当前新根为另一棵非空子树 否则如果\(val _a &lt; val _b\)，合并\(a\)的右子树和\(b\)，并作为\(a\)的新右子树，当前新根为\(a\) 否则合并\(a\)和\(b\)的左子树，并作为\(b\)的新左子树，当前新根为\(b\) 注意合并的顺序。如步骤2不能把\(b\)的左子树与\(a\)合并，这样没有保证合并的两个 Treap 是有序的。合并的过程仍要保持相对有序。同时修改了儿子的节点需要维护。 12345678910111213Node* Merge(Node *a,Node *b)&#123; if(a==NULL)return b; if(b==NULL)return a; if(a-&gt;r &lt; b-&gt;r)&#123; a-&gt;ch[1]=Merge(a-&gt;ch[1],b); a-&gt;Maintain(); return a; &#125;else&#123; b-&gt;ch[0]=Merge(a,b-&gt;ch[0]); b-&gt;Maintain(); return b; &#125;&#125; 分裂 分裂过程仍然是递归，需要返回两个分裂的节点。具体的过程可以画图模拟加深理解。分裂过程让我们把一个区间分成两个，实现了对序列中特定区间的操作，则像是区间翻转之类的操作也可以实现了。算法步骤如下： 如果该节点为空节点则返回一对空节点 否则如果分裂的位置在左子树，递归分裂左子树，并将当前根节点左儿子设为分裂的第二个节点，返回这对节点 否则递归分裂右子树，并将当前根节点右儿子设为分裂的第一个节点，返回这对节点 修改了儿子节点的节点需要维护。 123456789101112131415161718pNode Split(Node *o,int k)&#123; pNode ret(NULL,NULL); if(o==NULL)return ret; int l=o-&gt;ch[0]-&gt;Size(); if(k&lt;=l)&#123; ret=Split(o-&gt;ch[0],k); o-&gt;ch[0]=ret.second; o-&gt;Maintain(); ret.second=o; &#125;else&#123; ret=Split(o-&gt;ch[1],k-l-1); o-&gt;ch[1]=ret.first; o-&gt;Maintain(); ret.first=o; &#125; return ret;&#125; 扩展操作 插入 (Split+Merge ) 删除 ( Split +Split +Merge) 查询节点 / 区间 ( Split+Split+ Merge ) 查询第k大 ( Split +Split+Merge) 区间标记 ( Split+Split+Lazy +Merge) …… 所有的操作都可以把操作区间拆除来再做。不过我们重点考虑区间标记这个操作。 我们把 Treap 当成一个二叉搜索树，却忘记它也是一棵树，也可以进行树的操作。联想一下同为二叉树的线段树，我们也可以把 Treap 当线段树使用。不过更多的，Treap 用来维护与区间翻转有关的序列更多，因为线段树不支持这样的操作。另外，查询区间和、查询最大值这些信息只需要存在节点并一同维护即可，必要的时候可以用 Lazy 标记并Pushdown。 可持久化Treap 来自非旋转 Treap。其Merge与Split都是自上而下的递归操作，并且父子关系不会中途改变，因此我们可以实现可持久化。每次 Split 与 Merge 的时候，都对该节点复制一个新节点，则对这些新节点的操作不影响历史节点。 这里有一个空间优化。对于一般的先 Split后 Merge操作，Merge 影响到的节点是Split创建的新节点与将要合并的新节点。这两个节点有个特征，就是它们不会影响其历史版本，因此我们可以直接在Merge过程覆盖掉它们，而不需要再为新节点创造新节点。 我认为是，Split创造的新节点是分裂处的节点，而分裂处一定是中序遍历一段连续的位置，Merge操作是对结尾一段连续的位置进行修改，因此Merge操作的节点是Split新开的节点。（但是这个说法我也不能说服我自己。） 虽然不算难构造，但还是放上代码参考。对于新建的节点的时机，我的做法是决定了要处理的节点后，立刻对其进行复制并处理新节点，而不是等到下一层递归。这样会容易考虑和维护。 12345678910111213141516171819202122232425262728293031323334Node* Merge(Node *a,Node *b)&#123; if(a==NULL)return new Node(b); if(b==NULL)return new Node(a); Node *t=new Node(); if(a-&gt;r &lt; b-&gt;r)&#123; *t=*a; t-&gt;ch[1]=Merge(t-&gt;ch[1],b); &#125;else&#123; *t=*b; t-&gt;ch[0]=Merge(a,t-&gt;ch[0]); &#125; t-&gt;Maintain(); return t;&#125;pNode Split(Node *o,int k)&#123; pNode ret(NULL,NULL); if(o==NULL)return ret; int l=o-&gt;ch[0]-&gt;Size(); Node *t=new Node();*t=*o; if(k&lt;=l)&#123; ret=Split(t-&gt;ch[0],k); t-&gt;ch[0]=ret.second; t-&gt;Maintain(); ret.second=t; &#125;else&#123; ret=Split(t-&gt;ch[1],k-l-1); t-&gt;ch[1]=ret.first; t-&gt;Maintain(); ret.first=t; &#125; return ret;&#125; 练习 基础 BZOJ3224 普通平衡树 基础平衡树操作。 NOI2004 郁闷的出纳员 基础平衡树操作。注意一开始没有加入的员工是不计算在内的。 HNOI2002 营业额统计 平衡树维护前驱后继。 HNOI2004 宠物收养所 同一时刻收养所只有人和宠物表示要么人等宠物，要么宠物等人。标记表示现在收养所里是宠物还是人，维护平衡树即可。 进阶 SDOI2008 郁闷的小J 一个比较直观的在线做法是线段树套平衡树，每个节点放一棵平衡树，区间统计出现次数。当然也有树状数组的离线做法，按照查询书的种类排序后按类处理。如果数据小可以莫队。 ZJOI2007 报表统计 MIN_GAP就是维护相邻元素差绝对值的最小值，用一个小根堆维护值即可。注意如果添加了新元素，则与前一个元素相关的差值要删除，并添加两对新差值。MIN_SORT_GAP平衡树维护前驱后继。 HNOI2012 永无乡 Treap 的启发式合并，并查集维护。 BZOJ3223 文艺平衡树 Splay当然可以，不过非旋转式Treap也可以。 BZOJ3196 二逼平衡树 线段树套平衡树。Kth 查询需要二分判定答案，再判定 Rank 是否满足。 NOI2003 文本编辑器 需要区间操作的 Splay 或非旋转式 Treap。注意一次插入的文本可能会很大。 AHOI2006 文本编辑器 同NOI2003 文本编辑器，但增加了Rotate操作。 BSOJ4531 可持久化平衡树 就是可持久化平衡树。 较难 NOI2005 维护数列 需要很多线段树的操作。注意细节。（但我还没写Orz） 总结 Treap 可以维护集合内部的排名，但是非相对有序时不能高效合并。 非旋转 Treap 能在相对有序时高效合并与分裂，可以提取区间单独操作。 非旋转 Treap 每一个子树的中序遍历维护一个相对有序的序列，可以实现区间旋转，也可以像线段树一样维护一段序列的信息。 非旋转 Treap 父子形态稳定而不需要旋转，且操作自上而下，可以实现可持久化。 多区间查询 Kth 时，通常采用二分答案判定 Rank。]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>Treap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树算法总结]]></title>
    <url>%2Fsummary%2Ftree-algorithm%2F</url>
    <content type="text"><![CDATA[树是一类特殊的图，一棵树是拥有\(n\)个节点与\(n-1\)条边的无向联通图。树的性质很多，因此关于树的算法也不少。 ##树的直径 即树上最远的点对距离，可以用DFS或动态规划在$\(\mathrm{O}(n)\)的时间内处理。NOIP内容，不细讲。 可以证明，每个点在树上的最远点一定是直径的两端。 ###DFS 随意从树上一个点DFS找到距离最远的点\(u\)，再从\(u\)开始DFS找到距离最远的点\(v\)，则直径为\(u\to v\)。 ###动态规划 对每个节点记录它能到达最深和次深的距离\(dep_{i,0},dep_{i,1}\)。考察节点\(u\)的每个子树\(v\)： 若\(dep_{v,0}&gt;dep_{u,0}\)，则用\(u\)的最大值更新\(u\)的次大值，用\(v\)的最大值更新\(u\)的最大值； 否则若\(dep_{v,0}&gt;dep_{u,1}\)，用\(v\)的最大值更新\(u\)的次大值； 否则考察下一个节点 则直径为\(max_{u\in V}\{dep_{u,0}+dep_{u,1}\}\)，初始状态为\(dep_{u,0}=dep_{u,1}=0\)。 ##最近公共祖先 求最近公共祖先（Lowest Common Ancestor）也是有点水。 ###RMQ 处理出树的欧拉序，则从\(u\)到\(v\)的欧拉序中必定经过\(LCA(u,v)\)，且是唯一一个深度最小的节点。用RMQ可以\[\mathrm{O}(n\log{n})$预处理，\](1)$回答。 ###并查集 这是离线做法，没写过。但是时间复杂度是$\(\mathrm{O}(n)\)的。 ###倍增 通过$\(\mathrm{O}(n\log{n})\)预处理每个节点\(u\)的\(2^k\)倍祖先\(anc_{u,k}\)（\(0\)倍祖先为父节点）。对于每次询问\((u,v)\)且假设\(dep_u\leq dep_v\)： 当\(dep_u&lt;dep_v\)时，找到最大的\(k\)使得\(anc_{u,k}\not= v\)，并将\(anc_{u,k}\)赋给\(u\)，直到\(dep_u=dep_v\)； 当\(anc_{u,0}\not=anc_{v,0}\)时，找到最大的\(k\)使得\(anc_{u,k}\not=anc_{v,k}\)，并将\(anc_{u,k}\)赋给\(u\)，\(anc_{v,k}\)赋给\(v\)，直到\(anc_{u,0}=anc_{v,0}\)； \(LCA(u,v)=anc_{u,0}\)。 单次询问时间复杂度$\(\mathrm{O}(\log{n})\)。第二步前需要特判\(u\)是否已经等于\(v\)。 ###树链剖分 大概什么时候会写树剖的总结。树剖的预处理复杂度为\[\mathrm{O}(n)$，单次询问时间复杂度\]()$，常数比倍增小。虽然树剖可以求LCA，但这算是树剖的附属品。 类似倍增，每次移动所在重链的\(top\)深度较大的节点到\(top\)的父节点，直到\(u=v\)。需要特判\(u\)和\(v\)在同一重链上的情况。 ##树的重心 即子树节点数最大值最小的节点。每次都从重心开始进行点分治保证了点分治的层数为$\(\mathrm{O}(\log{n})\)。 两次DFS（可能爆栈）或三次BFS即可解决。 ##树上不相交最长链 在树上选择两条链，使链和距离最大且没有公共边。 如果考虑反悔思想，则变得很容易。对第一次选择的链（直径）上的边权取反，则第二次若取到了相同的边相当于取消选择这条边。两次都取直径保证了距离和最大，而画个图可以发现两次的公共边等价于没有选择，且仍然是两条链。 感觉可以扩展到\(k\)条链的情况，但是看起来不一定有\(k\)条链（可以拆链成几段充数）。时间复杂度$\(\mathrm{O}(kn)\)。 ##树链剖分 终于到重点了。树链剖分（Heavy-Light Decomposition）就是将树分成不超过\(\log{n}\)条不相交的重链的方法。将树剖分后，就可以愉快地在树上使用线段树维护路径了。 剖分可以维护点，也可以维护边。但是都需要维护六个信息：子树大小\(siz\)、节点深度\(dep\)、父节点\(pa\)、重儿子编号\(son\)、所在重链顶节点\(top\)、节点在线段树对应编号\(idx\)。前四个可以在第一次DFS内求出，后两个需要在第二次DFS内求出。如果采用BFS需要三次。 上面这些变量的含义和方法可以在这里找到，此处不做赘述。 以下代码是基于点的树剖，基于边的树剖只需要改动\(idx\)就可以实现。 ​ 12345678910111213141516171819202122232425262728293031323334struct HLDcp&#123; SegTree t; //略去线段树定义 int dep[N],siz[N],pa[N],son[N],top[N],idx[N]; int nIdx; void Build()&#123; nIdx=dep[0]=siz[0]=son[0]=0; DFS1();DFS2(); t.Init(idx);t.Build(); &#125; void DFS1(int u=1,int pa=0)&#123; dep[u]=dep[HLDcp::pa[u]=pa]+1; siz[u]=1;son[u]=0; for(int i=0;i&lt;a[u].size();i++)&#123; int v=a[u][i]; if(v==pa)continue; DFS1(v,u); if(siz[v]&gt;siz[son[u]])son[u]=v; siz[u]+=siz[v]; &#125; &#125; void DFS2(int u=1,int pa=0)&#123; idx[u]=++nIdx;top[u]=u; if(son[pa]==u)top[u]=top[pa]; if(son[u])DFS2(son[u],u); for(int i=0;i&lt;a[u].size();i++)&#123; int v=a[u][i]; if(v==pa||v==son[u])continue; DFS2(v,u); &#125; &#125;&#125;; 树剖相当于将树映射到某个线性序列上，使得树能使用线性序列的数据结构（如线段树）。树剖的查询过程需要经过不超过\(\log{n}\)条边，因此如果写线段树，则单次时间复杂度为\[\mathrm{O}(\log^2{n})$；如果写树套树则为\](^3{n})\(；如果写带修改区间第\)k\(大则为\)\(\mathrm{O}(\log^4{n})\)。 ##树分治 树分治可以基于点，也可以基于边。基于点的点分治每次找重心保证了不超过\(\log{n}\)层，而边分治十分不稳定。 参考09年论文《分治算法在树的路径问题中的应用》漆子超。 （因为只看了点分治，就只谈点分治吧。） ###点分治 感觉没有题目都不懂怎么往下讲 一般用来解决树上点对或路径有关的题目，且结果具有高效可合并性。 ####树上点对统计 题意：给定n个节点的带权无向树，统计树上距离不小于\(k\)的点对数。\((n\leq 10^5)\)。 最入门的点分治题目。假设我们在某一次分治已经找到重心\(u\)，并对其子树完成了分治。现在考虑怎么合并。 求树上距离我们能想到之前提过的动态规划方法。假设我们已经得到了所有点的深度，那只需要排序后两个指针一前一后扫一次就可以在\[\mathrm{O}(n)$统计了。要得到所有子树的深度可以一次DFS获得，时间复杂度也是\](n)$。 然而我们发现这个方法会把子树中满足条件的点对也计算到经过\(u\)节点的满足条件节点对数，那么从结果里减去每个子树满足的点对数就可以了。 ###边分治 哈？ ###链分治 哈？ ##题目 怎么还没讲完就到题目了 ###树型动态规划 ####APIO2010 巡逻 添加一条边能让新出现的环总体减少一次经过次数，添加两条边能让两个环不重复的部分减少一次经过次数（重复的部分仍然需要经过两次），并且这个部分恰好是两条链。因此找树上不相交最长链，从总数减去即可。 ####概率充电器 是个好题。重点有两个： 化正为反 化并为交 具体来说是指对每个节点\(u\)，考察被父节点或子节点充电化为考察既不被父节点又不被子节点充电。因为概率中求交要比求并方便多了。虽然我想到了化正为反，但是我陷入了同时考虑节点自己点亮或被相邻节点点亮的复合情况，并且没有处理好节点间的关系。如果处理好了就不难想到树型DP的方程。当然规模太大，需要BFS。 假设\(f_u\)为不被子树和自己充电的概率，\(g_u\)为不被父亲充电的概率，\(P\)为父亲不被\(u\)之外的点充电的概率，则： \[ f_u=(1-p_u)\sum_{v\in son} [f_v+(1-f_v)(1-w_{u,v})] \\ P=g_{pa_{pa}}\cdot \frac {f_{pa}}{f_u+(1-f_u)(1-w_{u,pa})} \\ g_u=P+(1-P)(1-w_{u,pa}) \] 即两种情况：充电但连边不通，不充电。 ###树链剖分 ####CTSC2008 网络管理 一开始的想法很naive，就是树剖之后再线段树套Treap维护区间第\(k\)大。然后复杂度大得要命。估摸着二分答案+树剖+线段树查询+平衡树查询一共$\(\mathrm{O}(n\log^4{n})\)，竟然也能过。 不过正解是只需要主席树。毕竟区间第\(k\)大可以很轻松用可持久化线段树维护（需要离散化），然后我们发现这就是一个带修改的可持久化线段树，用树状数组的方式维护\(n\)个可持久化线段树并统计就好了。其他做法同上。猜测复杂度二分答案+树剖+可持久化线段树查询+树状数组统计一共\[\mathrm{O}(n\log^4{n})$。然而并不是。按照DFS序的主席树套树状数组就是\](n^2{n})$。 ####BZOJ2819 Nim Nim游戏先手获胜\(\Leftrightarrow\)异或不为\(0\)，然后就是树上异或查询了。异或满足交换率（三种位运算符单独考虑都满足结合率、交换率），然后可以线段树，然后可以树剖，然后..就被卡$\(\mathrm{O}(q\log^2{n})\)了。 可以不用树剖。树上的区间查询相当于欧拉序连续区间查询，每次更新\(u\)时只会对\(u\)的子树产生影响。因此每次查询\((u,v)\)时答案为\(st_v\ \mathrm{xor}\ ed_u\)，每次更新\(u\)时更新\([st_u,ed_u+1]\)即可。然后复杂度就降到$\(\mathrm{O}(q\log{n})\)了。 因此我们得到启发：如果修改只影响子树或祖先，则可以考虑在DFS序上用树状数组维护。下一题就是如此。 ####BZOJ4765 普通计算姬 （其实不是树剖） 每一次更新节点只会影响祖先节点，而每一次询问却是树上分散点集的和。我们先考虑询问单点的情况，则每一次更新就可以用DFS序+树状数组在\[\mathrm{O}(\log{n})​$维护前缀和（树剖\](^2{n})​$）。然而还有区间询问，不如考虑分块。 维护一个块，统计一个节点及其父节点在块\(i\)的总数，则每次更新可以在\[\mathrm{O}(\sqrt{n})$内完成。而对于不是完整块的查询可以直接用上面的方法单点查询。总时间复杂度\](q(+))$。 因此我们再次得到启发：当单点维护代价高时，区间查询可以考虑用分块维护。 ###树分治 ####SPOJ1825 Free Tour II 论文题。 点分治，维护到各个子树中不超过\(i\)个黑点\((i\leq siz_v)\)的最长路径。我们发现\(i&gt;siz_v\)的时候答案不会改变，因此我们可以认为这个状态数就是\(siz_v\)。 论文说合并可以用平衡树轻易实现，然而我没想到怎么维护。 合并的时候对子树大小排序，考察从当前子树\(v\)到之前子树经过\(min(lim,siz_v)\)个黑色节点的最长路径并合并。合并\(k\)个子树的时间复杂度为\[\mathrm{O}(\sum_{i=1}^k min_{j=1}^i\{siz_j\})=$\mathrm{O}(\sum_{i=1}^k siz_i)=$\mathrm{O}(siz_u)$。因此每层分治时间复杂度为\](n)\(，对不超过\)n\(条边的排序时间为\)\(\mathrm{O}(\log{n})\)，因此总时间复杂度为$\(\mathrm{O}(n\log{n})\)。 ##总结 树具有许多性质，利用这些性质可以在树上进行动态规划、剖分和分治。 若给出了一个序列，序列间的关系只与\(a_{i}\)和\(a_{\lfloor i/2 \rfloor}相关\)，则这个序列的关系可以构成一棵二叉树。 不相交最长链的反悔思想：反权边。这在网络流里也有体现。 树的遍历通常采用DFS，但数据过大时需要采用BFS。树的特性保证了其在拓扑序下也可以合并结果。 在一类合并子树的动态规划/树分治的过程中，如果时间复杂度和当前已合并的子树大小有关，可以按子树大小顺序合并。这在一些题目中可以降低、保证复杂度。 如果修改只影响子树或祖先，则可以考虑在DFS序上用树状数组维护而不是树剖。当单点维护代价高时，区间查询可以考虑用分块维护。 然后我就喵喵喵了TAT]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流总结]]></title>
    <url>%2Fsummary%2Fnetwork-flow%2F</url>
    <content type="text"><![CDATA[网络流，就是一张有向图中给每一边分配一个容量，流可以沿着有容量的边移动。对一个给定的网络，其一个可行流为从源点到汇点的一种流量方案。 网络流问题就是解决最大流、可行流、费用流等抽象问题的一种模型。对一个可行流来说，它有如下特性： 除了源汇点外，每一个点的入流与出流相等 经过每条边的流量不超过该边容量上限 则最大流就是到达汇点的流量最多的一个可行流，它也满足上述性质。 ##最大流 求最大流可以采用 Dinic、SAP、ISAP 等算法，但我们主要介绍 Dinic。Dinic 算法分为寻找分层图与增广两个部分。下面不加解释地放上 Dinic 的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct Dinic&#123; struct Edge&#123;int v,res;&#125;; vector&lt;Edge&gt; edg; vector&lt;int&gt; a[V]; int st,ed; void AddEdge(int u,int v,int cap)&#123; edg.push_back((Edge)&#123;v,cap&#125;); edg.push_back((Edge)&#123;u,0&#125;); int siz=edg.size(); a[u].push_back(siz-2); a[v].push_back(siz-1); &#125; int dep[V]; bool BFS()&#123; memset(dep,-1,sizeof(dep)); queue&lt;int&gt; q; q.push(st);dep[st]=0; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;a[u].size();i++)&#123; Edge e=edg[a[u][i]]; if(dep[e.v]==-1&amp;&amp;e.res&gt;0) q.push(e.v),dep[e.v]=dep[u]+1; &#125; &#125; return dep[ed]!=-1; &#125; int cur[V]; int DFS(int u,int minF)&#123; if(u==ed||minF==0)return minF; int tmpF,sumF=0; for(int &amp;i=cur[u];i&lt;a[u].size();i++)&#123; Edge &amp;e=edg[a[u][i]]; if(dep[e.v]==dep[u]+1&amp;&amp;(tmpF=DFS(e.v,min(minF,e.res)))&gt;0)&#123; e.res-=tmpF,edg[a[u][i]^1].res+=tmpF; sumF+=tmpF;minF-=tmpF; &#125; if(minF==0)break; &#125; return sumF; &#125; int MaxFlow()&#123; int ret=0; while(BFS())&#123; memset(cur,0,sizeof(cur)); ret+=DFS(st,INF); &#125; return ret; &#125;&#125;; 上述代码用残量表示边的流量数据。对这份代码的解释很容易在网络上找到，在此不做赘述，而只点出实际写时的易错点： 寻找分层图时，不能经过残量为0的边。 利用当前弧结构保存时，每一次寻找增广路前要清零。并且寻找增广路时要使用引用来更新当前弧。 寻找增广路时要对当前边进行修改，因此要对边使用引用而不能单纯复制内容 对边的四个操作要保证修改的对象和数值是否正确 如果流量为double类型，需要DCmp判断是否为0，而不能直接与0比较 这是一些很naive且很容易忘记的错误。放出以警示自己。 ###带上下界的流 带上界的流一般都采用拆点的方式建图来保证其上下界功能。考虑好必须经过的流量是哪些，可以经过的流量是哪些。 ####带上下界可行流 #####无源汇 对于$E = ( u , v ) \(，若其流量限定为\) [ low , upp ]$，则我们可以先考虑特殊情况。 没有下界：普通的网络流，从\(u\)向\(v\)连容量为\(upp\)的边。 没有上界：\(u\)节点必须输出\(low\)流量，\(v\)节点必须流入\(low\)流量。根据这个条件，可以考虑从\(u\)向\(t\)连流量为\(low\)的边，从\(s\)向\(v\)连流量为\(low\)的边，这样就满足了上述条件。 我们发现这两个不互相干扰，一起使用即可。明显，整个网络拥有一个可行流的等价条件是，新增的下界边都满流，否则没有可行流。 由于新网络入流与出流相等，而无源汇的网络满足流量平衡，因此s的出流等于t的入流，也就满足了新增加的边如果从\(s\)得到了流量，则一定跑到了\(t\)，而不会中途消失。此时t的最大流就是经过这些下界边的总流量。 #####有源汇 从\(t\)向\(s\)连一条容量为\(\infty\)的边，这样网络就变成无源汇的上下界，跑可行流即可。之所以需要变成无源汇而不能拆边后直接跑，是因为无源汇的网络做法考虑了流量平衡，而有源汇的网络明显源汇是不平衡的。如果不连$( t , s ) \(的边，那么改建后原网络的\)s$根本就没有流量。这很明显不可行。 ####有源汇带上下界最大流 #####普通做法 我们的立足点是无源汇上下界可行流的求法，因此考虑把有源汇先转成无源汇。按照无源汇可行流的方法建图并跑最大流，得到的是一个原图的可行流，此时的下界应该是填满的（显然，不填满就连可行流都没有）。在残余网络上从原图的\(S\)到\(T\)跑最大流就是答案。（当然我不是很理解。） #####二分做法 我们仍转换为无源汇，但是设从\(T\)到\(S\)的边有下界\(x\)，并跑无源汇可行流。明显，如果新图具有可行流，则说明原图能有\(x\)的流量从\(S\)到达\(T\)，否则没有。这个性质可以二分。 ####带上下界最小流 如果不带上下界，则最小流就是零流，没有什么好求的。 #####普通做法 考虑转化为无源汇，但这次我们不连接从\(T\)到\(S\)的边，直接跑\(SuperS\)到\(SuperT\)的最大流。再加上从\(S\)到\(T\)的边，从\(SuperS\)到\(SuperT\)跑一次最大流。若从\(S&#39;\)出发的边满流，则\(( T , S )\)的流量为最小流，反之无解。（当然我不是很理解。） #####二分做法 我们仍转换为无源汇，但是设从\(T\)到\(S\)的边有下界\(x\)，并跑无源汇可行流。明显，如果新图具有可行流，则说明原图能有\(x\)的流量从\(S\)到达\(T\)，否则没有。这个性质可以二分。 ####总结 我们所有上下界流的基础都是建立在上下界无源汇可行流上，因此这个模型的转换是很重要的。另外，上下界最大/最小流的二分解法虽然比普通解法多出一个\(\log\)，但是却很容易理解。实际运用上应该是足够的。 ##最小割 流网络$ G = ( V , E ) \(的割（Cut）\) [ S , T ] \(将点集\) V \(划分为\) S \(和\) T ( T = V − S )\(两个部分，使得源\) s ∈ S \(且汇\)t ∈ T \(。符号\) [ S , T ] \(代表一个边集合\) { u , v | u , v ∈ E , u ∈ S , v ∈ T } \(。割\) [ S , T ] \(的容量（Capacity）定义为\) c ( S , T ) \(，一般记为\) c [ S , T ] $。一个网络的最小割也就是该网络中容量最小的割。（定义来自《最小割模型在信息学竞赛中的应用》 胡伯涛） 注意边集中方向为\(T\to S\)的边的容量不计算在割集内。即最小割的容量只为顺着\(S\to T\)到达的边的容量和。 最小割拥有一些不错的性质： 最小割将点集分割成两个部分，且最小割只包含了两端点属于不同点集的边的容量 最大流最小割定理：一个网络中的最大流等于最小割 第二个性质很重要，它给了我们一个求最小割的方法。而第一个性质给了我们一个转换模型的思路。我们给出如下性质： 最小割一定是最大流中的满流边，但满流边不一定是最小割中的边 这个性质的反例可以在论文中找到。因此寻找最小割边时，需要从源点DFS顺着有残量的边遍历，则两端点只被遍历一个的边为最小割边。注意这个有残量的边包括网络中的反边，有些点可能能从反边被到达，因此需要DFS而不能单独认为满流边就是最小割边。 ###平面图最小割 可以参考论文《两极相通——浅析最大—最小定理在信息学竞赛中的应用》周冬。 平面图的对偶图：把平面图的面当点，连接两个面的边当两个点的边的图。平面图有不错的性质： 欧拉公式：顶点数$ + \(面数\) - \(边数\) = 2$ 平面图的对偶图也是一个平面图 对一个源汇点都在无界面的边界的网络，如何根据平面图求它的最小割？我们从 \(S\) 到 \(T\) 连接新边创建出附加面，并对这个图创建对偶图，其中\(S&#39;\)和\(T&#39;\)为对偶图在附加面与无界面的点。则我们画个图就能发现，$S' \(到\) T'$的一条路径就是原图的一个割。因此原图的最小割相当于新图的最短路径。 我们得到一个感受：当原问题不好入手时，考虑它的对偶问题。 ###最大权闭合图 这类题目是求具有依赖关系的最大权子图：选择A会有一定权值，但同时要选择B和C，它们也会产生权值，这样的关系构成一张有向图。选择有向图的一个子图，使得若\(v\)在点集，则\(v\)的出边指向的点也在点集。 对这类题目的详解在论文有。此处只阐明算法： 对原图的所有边容量赋为\(\infty\) 从\(S\)向正权点连权值为\(w\)的边 从负权点向\(T\)链权值为\(-w\)的边 最大权闭合子图 = 正权点权和 - 新图最小割 ##二分图最大匹配 二分图本身就有一个两端属于不同点集的边集，因此二分图常常被询问最大匹配。最大匹配即，选定一个边集，使得边集中的所有点不相交。二分图的最大匹配有\(\mathrm{O}(nm)\)的匈牙利算法（Hungarian Algorithm），非二分图的最大匹配需要带花树算法（Blossom Algorithm）。 不加注释地给出匈牙利算法代码： 12345678910111213141516171819bool vst[N];int lnk[N];bool DFS(int u)&#123; for(int v=1;v&lt;=nV;v++) if(g[u][v]&amp;&amp;!vst[v])&#123; vst[v]=1; if(!lnk[v]||DFS(lnk[v]))&#123; lnk[v]=u; return 1; &#125; &#125; return 0;&#125;int ans=0;for(int i=1;i&lt;=nV;i++)&#123; memset(vst,0,sizeof(vst)); if(DFS(i))ans++;&#125; 这个算法给出的是邻接矩阵做法，我们可以很轻易地改为邻接表。需要注意的点： 每次开始搜索前，清空访问数组 只有没有访问的节点可以操作 ##图的性质 明确以下概念： 点相关 最小点覆盖 最大独立集 最小点权覆盖 最大点权独立集 边相关 最小边覆盖 最大匹配 这些概念都可以在论文中找到具体定义，但我们重点讨论它们的性质： 最大匹配数\(+\)最小边覆盖数\(=\)顶点数（条件：联通图） 最大独立集\(+\)最小点覆盖数\(=\)顶点数 König定理：最大匹配数\(=\)最小点覆盖（条件：二分图） 最大流\(=\)最小割 最小割\(=\)最小点权覆盖集（条件：二分图） 最小点权覆盖集数\(+\)最大点权独立集数\(=\)顶点数（条件：二分图） 大部分性质都可以概括为：最值$ = \(最值，最小\) + \(最大\) = ​$顶点数。后三条可以得到一个计算最大点权独立集的有效算法。具体的讨论和证明可以参考《两极相通——浅析最大—最小定理在信息学竞赛中的应用》周冬。 ##最小费用最大流 给网络中的每一个边一条边权，求使得最大流的情况下的最小费用。下面不加注释地给出代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657struct Dinic&#123; struct Edge&#123;int v,w,res;&#125;; vector&lt;Edge&gt; edg; vector&lt;int&gt; a[V]; int st,ed;void AddEdge(int u,int v,int w,int cap)&#123; edg.push_back((Edge)&#123;v,w,cap&#125;); edg.push_back((Edge)&#123;u,-w,0&#125;); int siz=edg.size(); a[u].push_back(siz-2); a[v].push_back(siz-1);&#125;int dis[V],pa[V],det[V];bool SPFA()&#123; static int inQ[V]; memset(inQ,0,sizeof(inQ)); memset(dis,0x3f,sizeof(dis)); deque&lt;int&gt; q;q.push_back(st); dis[st]=0,inQ[st]=1,det[st]=INF,pa[st]=-1; while(!q.empty())&#123; int u=q.front();q.pop_front();inQ[u]=0; for(int i=0;i&lt;a[u].size();i++)&#123; Edge &amp;e=edg[a[u][i]]; if(e.res&gt;0&amp;&amp;dis[e.v]&gt;dis[u]+e.w)&#123; dis[e.v]=dis[u]+e.w; det[e.v]=min(det[u],e.res); pa[e.v]=a[u][i]; if(!inQ[e.v])&#123; if(!q.empty()&amp;&amp;dis[q.front()]&gt;=dis[e.v])q.push_front(e.v); else q.push_back(e.v); inQ[e.v]=1; &#125; &#125; &#125; &#125; return dis[ed]!=INF;&#125;void Augment(int &amp;w)&#123; w+=dis[ed]*det[ed]; int u=ed; while(u!=st)&#123; edg[pa[u]].res-=det[ed]; edg[pa[u]^1].res+=det[ed]; u=edg[pa[u]^1].v; &#125;&#125;int MaxFlowMinCost()&#123; int ret=0; while(SPFA())Augment(ret); return ret;&#125; 要点： 增广过程与SPFA相似，但仍要注意只有有残量的边可以通过。 SPFA过程注意是否出队入队，是否取消标记，是否入对位置正确。 ###费用流拆边 一条边所花费的费用是随流量线性增长。如果呈二次增长，甚至三次增长呢？需要拆边。 假设$f \(为流量，\)cap \(为边容量，\)w = f ^ 2 \(为费用，则当\) f = 1 \(时\) w = 1 \(，\) f = 2 \(时\) w = 4\(，\) f = 3 \(时\) w = 9 \(。我们把边拆为\) cap $条，每条容量是\(1\)，费用分别是\(1,3,5,\dots\)则不难发现在流量相同时，费用会选择最小的$ f \(条，而这\) f \(条的费用加起来刚好为\) w= f ^ 2$。当流量呈更复杂的多项式时，可以利用导数将边拆分。但很明显拆边有前提：流量必须是整数，多项式导数必须递增。 ###带权二分图匹配 如果有权，则可以给边赋权用费用流求解匹配。从\(S\)向\(X\)集合、从\(Y\)集合向\(T\)连权值为点权、容量为\(1\)的边，跑最大流最小费用即可。 ##练习 ###最大流 ####USACO4.2.1 草地排水 最大流模板题目。 ####BSOJ1721 上下界可行流 &amp; BSOJ1723 上下界最大流 &amp; BSOJ1725 上下界最小流 上下界网络流的练习题。 ####BSOJ2547 网络流24题-6 最长递增子序列 第二问可以考虑每个点只能被选一次，并且假设当前节点结尾的LIS为$ d \(，则当前节点只能向后面 LIS 为\) d + 1 $的节点（否则不是LIS）连容量为\(1\)的边。最后$ S \(连\) d $为\(1\)的点，$ d \(为全局LIS的点向\)T\(连，跑最大流即可。第三问只需要修改部分点流量为\)$。 ####SDOI2015 星际战争 二分答案判断最大流是否足够。注意精度。 ###二分图最大匹配 ####SCOI2015 小凸玩矩阵 二分答案\(ans\)，\(X\)集合为行，\(Y\)集合为列，选中一个元素等于匹配两个点，每次只能选择小于等于\(ans\)的元素。判断这些元素（匹配）是否有$ ( n - k + 1 ) \(个。注意第\)k\(大而不是第\)k$小。 ####USACO2005NovGold Asteroids 有行星的位置连接一条边，求最小点覆盖。可转化为最大匹配。 ####USACO2005JanGold 泥泞的牧场 注意到每个点只能被横行或纵列覆盖（可以同时覆盖）。对于连续的泥泞，我们一块木板盖上是最好的。因此我们可以把图分块。横向的分块与纵向的分块编号后，一个泥泞就只能对应一条横向与一条纵向分块的交点了。 题目相当于转化为选择尽量少的分块，使得每个交点都被覆盖。如果把分块变成左右两端的点，交点变为它们之间的边，则原题目化为最小点覆盖。为什么可以转化？我们发现两个块要么有交点，要么没交点，并且只有横向块与纵向块相交，这完全符合二分图性质。 ####BSOJ1775 xinyue的约会 同上，但需要考虑有些边不需要添加。 ####BSOJ2569 网络流24题-3最小路径覆盖 把每个点拆成入点和出点，这样一个匹配就是一个边。在匹配中，每一个点的前驱和后继是唯一的，而只有起点不存在前驱，终点不存在后继。有多少个点没有前驱或后继，就有多少条路径。因此对于一个匹配，其路径数 = 点数 - 匹配数。 因此，最少路径 = 点数 - 最大匹配。 有关路径的问题可以将其拆成二分图，再观察路径的性质。 ###最小割 最小割的题目算是比较有价值，也是比较难转换的模型题目。 ####POJ2125 Destroying the Graph 每条边可以被入点破坏也可以被出点破坏。因此构造二分图求最小割。 ####POJ3469 Dual Core CPU 考虑没有额外代价的情况，则一个任务只能在两个 CPU 的其中一台运行。这个就是最小割模型，$S \(向任务\) i \(连边权为\) a_i\(的边，\)i \(向\) T \(连边权为\) b_i\(的边，则最小割就把所有点集分成两个部分（要么属于\) S \(，要么属于\) T $），且使得所有割边代价最小。 考虑加上代价。我们希望当$ a \(与\) b \(不在同一个点集时能有额外的权\) w _i\(，这很像最小割的定义，因此我们考虑把\)w_i\(也加入到最小割。具体做法是在\) a \(与\) b \(之间连边权为\) w_i\(的无向边，这样当\) a \(与\) b $在同一个集合时此边不会是割边，而不在同一个集合时，会把额外代价计算。这就解决了问题。 往往要从定义出发：割边是连接两个属于不同集合的点的边集。下面的题目也显示出这个特点。 ####SPOJ839 Optimal Marks 我们发现因为存在位运算，所有边权的总和最小等价于边权的每一位总和最小。因此单独考虑每一位，且每一位都只有$ 0$和$1 $可以取。注意到xor的定义是两个数不同则为\(1\)，相同为\(0\)，边权只有端点的两个数不同时才被计算，这和最小割的定义同样很像。 因此最小割模型显然。把两个集合当成选择的值，向每个点连接容量为\(\infty\)的边，有边相连的两个点连容量为$ 1 \(的边。这么做的目的是：割边只能在**特定的边**取到，而不能在**容量为**\)$的边取到。对每一位跑一次最小割即可。 我们得到一个直观的感受：如果一条边不想成为割边，只需要把容量设为\(\infty\) 。 ####ZJU2676 Network Wars 见论文。此处重点讨论细节。 对给定网络，我们需要选出一个最小割集。由于分数规划使得边权可能为负，而负边权相当于反边，是不会被计算在最小割的容量的，因此需要手动叠加，而只对边权$ &gt; 0 $的边求割。 ####BSOJ2550 网络流24题-9 方格取数问题 对棋盘黑白染色后发现相邻的不同颜色点之间只能选择其中一个。因此把有冲突的点连边，求最大独立集（权为\(1\)的最大点权独立集）即可。注意是二分图，转化求最小点权覆盖集\(\to\)最小割\(\to\)最大流。 ####CQOI2017 老C的方块 题目描述很复杂，大致就是在一个特殊的网格上不能有特定图形出现，而去除一个网格需要一定费用。 然后我们观察四个图，发现特殊边两侧刚好连接两个格子。“某些状态不能共存，而去掉某个状态需要一定代价”的想法让我们想到最小割（虽然数据范围上不是这样的）。因此有这些形状的格子要连接起来，并且至少有一个连接源点或汇点。经过一番构图，我们构造出下面这种网络： \[ \begin{matrix} \vdots &amp; &amp;\vdots &amp; &amp;\vdots &amp; &amp;\vdots &amp; &amp;\vdots &amp; &amp;\vdots\\ \downarrow &amp;\Leftarrow &amp;\leftarrow &amp;\leftarrow &amp;S &amp; &amp;T &amp;\leftarrow &amp;\leftarrow &amp;\Leftarrow &amp;\leftarrow &amp;\cdots\\ \downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow &amp; &amp;\uparrow &amp;\\ T &amp; &amp;S &amp;\rightarrow &amp;\rightarrow &amp;\Rightarrow &amp;\rightarrow &amp;\rightarrow &amp;T &amp; &amp;S &amp;\cdots\\ \uparrow &amp; &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow &amp;\\ \uparrow &amp;\Leftarrow &amp;\leftarrow &amp;\leftarrow &amp;S &amp; &amp;T &amp;\leftarrow &amp;\leftarrow &amp;\Leftarrow &amp;\leftarrow &amp;\cdots\\ \downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow &amp; &amp;\uparrow &amp;\\ T &amp; &amp;S &amp;\rightarrow &amp;\rightarrow &amp;\Rightarrow &amp;\rightarrow &amp;\rightarrow &amp;T &amp; &amp;S &amp;\cdots\\ \uparrow &amp; &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow &amp; &amp;\uparrow &amp; &amp;\downarrow &amp;\\ \uparrow &amp;\Leftarrow &amp;\leftarrow &amp;\leftarrow &amp;S &amp; &amp;T &amp;\leftarrow &amp;\leftarrow &amp;\Leftarrow &amp;\leftarrow &amp;\cdots \end{matrix} \\ \text{（有没有想到洋流图）} \] 每个交点是原图中的一个方块，双线箭头代表图中的特殊边。我们在这张网络图上能发现原图中的四种方块都对应一条从\(S\)到\(T\)的边，我们只需要求最小割就是最小花费。问题是怎么设置边权。 明显处于\(S\)和\(T\)上的点应该各自连\(w\)到\(S\)或\(T\)，那特殊边两侧的两个方块呢？如果要删掉一个方块，则只需要删掉一个就好了，两个同时删是不划算的。因此我们只需要给特殊边设两个方块的较小\(w\)即可。 虽然本题点的规模达到了\(10^5\)，但棋盘很大，连边只在相邻的方块出现，因此边数不大。跑跑最大流就过了。 是道建图好题。我们可以得到一个直观感受：最小割可以解决不共存的最小代价问题。这跟上面利用割的定义最小化分点代价不同，其出发点是源汇点的联通性。 ###最大权闭合图 ####BSOJ2543 网络流24题-2 太空飞行计划 很明显的最大权闭合图模型，直接转化。 ####NOI2006 最大获利 见论文。选定一个边同时要选定两个点，转化模型。 ####TJOI2015 线性代数 转化题目后发现相当于有许多物品，要得到物品$ i \(和\) j \(需要先选定\) i \(和\) j\(，而选定\) i \(和\) j$都需要代价。接着就可以做了。 有个神奇的做法是暴力寻找不要什么物品，时间复杂度$ ( n ^ 3 n )$，跑起来还挺快。 ###费用流 ####BSOJ4914 疯狂的方格取数 拆点。由于网络流与边有关，因此和点有关的题目往往需要把点拆掉来建立边。 ####ZJOI2010 网络扩容 第一个最大流很简单。 第二个我一开始估计是在残余网络上操作，然后跑个DP计算每条路径扩展k所需要的费用，再统计和即可。不过这不好实现还容易TLE。发现所需费用是费用流的表达式，但是如果直接跑费用流，我们希望有容量的边不计算权值，没流量的边计算权值，怎么办？ 残余网络中，原图都加一条边权为\(w\)，容量为\(\infty\)的边。再从超级源点\(s\)向\(1\)建边权为\(0\)，容量为\(det\)的边。这样，在跑费用流的时候，如果一个边有流量就会优先选择这条没有花费的边，否则只能选择有花费的新边。 这个思路挺巧妙的，虽然我觉得对\(n=1000,m=5000\)的数据跑\(\mathrm{O}(n^2m)\)有点夸张。不过据说Dinic的复杂度和SPFA一样是个迷，因此还是可以跑的。 ####SCOI2007 修车 本质上是一个打水问题，不过在不同的维修队列里花费时间也不一样。 费用流模型不难想到，可是具有后效性。然而我们发现把每个维修人员的 【未完成】 ####NOI2008 志愿者招募 题目太神，不会做。但是还是放上BYV 的题解。 具体的思路是把不等式添加变量修改为等式，这样容易思考。其次发现每个人都从某段时间开始，某段时间结束，可以考虑到差分。两者结合就得到了新的等式，并且由于差分的特性，每个有关变量都刚好出现两次且符号相反。 啧啧称奇。（虽然我不知道为什么推出来之后，需要求最大流。） ##总结 网络流通常用来求一类有限制（选择次数、不可同选）的题目。建模相比起算法往往更重要，因此如何构造网络是网络流题目的一个重点。 需要掌握图的点与边集关系，尤其是二分图 最大匹配数\(+\)最小边覆盖数\(=\)顶点数（条件：联通图） 最大独立集\(+\)最小点覆盖数\(=\)顶点数 König定理：最大匹配数\(=\)最小点覆盖（条件：二分图） 最大流\(=\)最小割 最小割\(=\)最小点权覆盖集（条件：二分图） 最小点权覆盖集数\(+\)最大点权独立集数\(=\)顶点数（条件：二分图） 网络流的建模入手点 有关选择的依赖关系的问题，可以考虑最大权闭合图 有关路径的问题可以按照出边入边将其拆成二分图，再观察路径的性质 有关等式或不等式，考虑流量平衡（如上下界网络流、志愿者招募） 有关不共存的最小代价，考虑最小割使源汇不联通的性质，在不共存状态间连边，再与源汇连边求最小割]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵总结]]></title>
    <url>%2Fsummary%2Fmatrix%2F</url>
    <content type="text"><![CDATA[矩阵是个很神奇的东西，可惜我涉猎较少，只能浅谈矩阵的应用。 我们先定义几个符号： \(A\)：矩阵\(A​\) \(A_i\)：矩阵\(A\)第\(i\)行 \(A_{i,j}\)：矩阵\(A\)第\(i\)行第\(j\)列的元素 \(M_{i,j}\)：矩阵\(A\)去掉第\(i\)行和第\(j\)列的矩阵（余子式） \(A^T\)：矩阵\(A\)的转置 \(A^n\)：矩阵\(A\)的\(n\)次幂 \(\det(A)\)：矩阵\(A\)的行列式 ##矩阵乘法 定义矩阵乘法\(A\times B=C,C_{i,j}=\Sigma_{k=1}^m A_{i,k}B_{k,j}\)，其中\(A\)是$n \(行\)m\(列、\)B\(是\)m\(行\)p$列的矩阵。矩阵乘法不满足交换率，但满足结合率和分配率。 在这种定义下，矩阵乘法满足交换率的情况： 两矩阵相等 两矩阵至少有一个为数量矩阵（主对角线为相同的数，其他为\(0\)） 两矩阵的乘积等于两矩阵的和（了解） ##矩阵的幂 根据矩阵乘法的定义，只有\(n\)行\(n\)列的矩阵（方阵）才有幂。 矩阵满足结合率，因此可以使用快速幂加速，计算大小为\(n\)的矩阵\(A^k\)时间复杂度\(\mathrm{O}(n^3\log{k})\)。如果加速矩阵乘法，可以降低复杂度，但在OI中这个复杂度就足够了。 利用矩阵的幂可以求线性递推式（如Fibonacci）。 ##邻接矩阵性质 假设\(A\)为\(n\)个节点的图\(G\)的邻接矩阵，则考虑一个矩阵乘法的过程： \[G_{i,j}^2=\Sigma_{k=1}^n G_{i,k}G_{k,j}\] 相当于枚举经过的\(k\)点，计算从\(i\)到\(j\)经过\(2\)条边的方案数。这个过程其实就是在模拟Floyd。因此我们猜测：\(G_{i,j}^k\)表示经过\(k\)条边\((k\geq 0)\)，从\(i\)到达\(j\)的方案数。事实上这是正确的。 如果我们重新定义矩阵乘法\(A\times B=C,C_{i,j}=min_{1\leq k\leq n}\{A_{i,k}+B_{k,j}\}\)，则我们发现\(G^2\)就是Floyd，\(G^k\)是一张经过\(k\)条边的最短路邻接矩阵。 这提示我们可以根据需要重新定义矩阵乘法，但是仍要保证新的定义满足结合率（不用考虑交换率是因为乘数相同已经满足了交换率）。 ##高斯消元 其实是求解一个线性增广矩阵。 假定有列数为\(n\)的矩阵\(A\)和大小为\(n\)的向量\(B\)，高斯消元可以解得满足\(A\times X=B\)的向量\(X\)。更一般地说，高斯消元可解\(A_i\times X_i=B_i\)的解向量\(X\)。 高斯消元的理论在很多资料和训练指南上都有，因此此处重点分析代码。 1234567891011121314151617void GausElim()&#123; for(int i=0;i&lt;n;i++)&#123; int cur=i; for(int j=i+1;j&lt;n;j++) if(fabs(a[j][i])&gt;fabs(a[cur][i]))cur=j; for(int j=0;j&lt;=n;j++)swap(a[i][j],a[cur][j]); for(int j=i+1;j&lt;n;j++) for(int k=n;k&gt;=i;k--) a[j][k]-=a[i][k]*a[j][i]/a[i][i]; &#125; for(int i=n-1;i&gt;=0;i--)&#123; for(int j=i+1;j&lt;n;j++) a[i][n]-=a[j][n]*a[i][j]; a[i][n]/=a[i][i]; &#125;&#125; 增广矩阵\(A\)的最后一列即为解向量。流程如下： 对项\(i\)找到系数绝对值最大的一行并交换（减小精度误差） 对\(i\)行之后的每一行\(j\)的每个元素\(A_{j,k}\)都减去\(A_{j,k} \times \frac {A_{j,i}}{A_{i,i}}\)。为了不破坏\(A_{j,i}\)，需要逆序进行； 对每一行都操作完毕后，逆序将已有的解代入当前方程组求解。 注意上面的求法是只有唯一解时的求法。如果枚举到某行的某一项\(i\)发现后面所有项\(i\)的系数都为\(0\)，则\(i\)为自由元（取值任意），并在该行考察下一项\(i+1\)。如果解完后\(i\)行的系数全为\(0\)而\(A_{i,n}\not=0\)，则原方程组无解。 ###模意义下的高斯消元 边做边模即可。注意因为取模，有可能会出现多解的情况。但是此时若有多解，解的个数是可数的，因此我们往往需要求解的个数。 给出结论：在模\(p\)意义下解方程组若有\(n\)个自由元，则方程组的解个数为\(p^n\)。 因此像上述一样统计自由元就好了。但是我们很担心\(p\)不是质数，否则我们做除法的时候逆元不一定存在。这里就有个神奇小技巧了。 ###辗转相除法求逆 假设我们要求\(A_i\leftarrow A_i-A_j*\frac {A_{i,i}}{A_{j,i}}\)。方便描述，我们令\(a=A_{i,i},b=A_{j,i}\)，然后： 令\(c=\lfloor \frac ab\rfloor\)，\(A_i\leftarrow A_i-c\cdot A_j\)； 令\(a\leftarrow a\bmod b\)，交换\(a,b\)，交换\(A_i,A_j\)； 当\(b\)不为\(0\)时重复1。 原理未知。但看起来过程是扩展欧几里得（上面的过程极有可能是错的）。 ###异或方程组 模\(2\)意义下的高斯消元，相当于采用异或运算。 ###矩阵求逆 不会。 ##行列式 定义函数\(sign(p)\)为全排列\(p\)中的逆序对数。对于方阵\(A\)，其行列式\(\det{A}\)定义： \[\det(A)=\Sigma_{p\in permutation} [(-1)^{sign(p)}\Pi_{i=1}^n A_{i,p_i}]\] 看起来就不好求。但是我们有性质： \(\det(A)=\det(A^T)\) \(\det(A)=-\det(A_{\text{swap(i,j)}})\) \(k\det(a)=\det{A_{A_i=kA_i}}\) 若\(A_i=kA_j\)，则\(\det(A)=0\) 若\(A=B+C\)，则\(\det(A)=\det(B)+\det(C)\) \(\det(A)=\det(A_{A_i=A_i+kA_j})\) 具体的证明和文字说明见这里。利用性质六，我们就可以进行高斯消元了。 具体步骤和高斯消元一样。根据性质二，交换两行需要乘\(-1\)。根据性质六，我们消元时应该用第\(j\)行减去第\(i\)行作为第\(j\)行的答案，而不能用第\(i\)行减去第\(j\)行。 消元完毕后，答案即为主对角线的乘积。因为不选主对角线上的数必定会选中\(0\)，对答案没有贡献。而主对角线的排列\(p\)逆序对数为\(0\)。这样我们就在\(\mathrm{O}(n^3)\)的时间内求出矩阵的行列式。 ##矩阵树定理 求无向图\(G\)的生成树个数。根据矩阵树定理（Matrix-Tree Theorem/Kirchhoff's Theorem），若\(G\)的Kirchhoff矩阵为\(K\)，则其生成树个数\(ST(G)\)为： \[ST(G)=\det{K_{i,i}}\] \(i\)的值无所谓。具体证明和推导见这里。 然而什么是Kirchhoff矩阵？令图\(G\)的度数矩阵为\(D\)，邻接矩阵为\(A\)，则\(K=D-A\)。更一般地，有： \[ K_{i,j}= \begin{cases} \deg(i),&amp;i=j\\ -1,&amp;(i,j)\in E\\ 0,&amp;otherwise \end{cases} \] 但是这样高斯消元容易有精度误差，解决方法未知，可以考虑分数类。不过一般都是在模意义下的高斯消元，然后就可以采用辗转相除的黑科技保证精度。 可以扩展到有向图上，求出来的是有向树。 ##特征值及特征多项式 哈？ ##练习 ###矩阵乘法 ####BZOJ3444 ⑨的故事 题意：求\(A^9\Sigma_{i=1}^n A^i\)。 由于矩阵乘法满足分配率，因此当\(n\)为偶数时有\(\Sigma_{i=1}^n A^i=(1+A^{n/2})\Sigma_{i=1}^{n/2} A^i\)，奇数的情况相同考虑。然后就可以分治了。 时间复杂度\(\mathrm{O}(n^3\log{n})\)。 ###矩阵快速幂 ####HNOI2002 公交车路线 我们能得到递推方程 \[ f_{i,j}= \begin{cases} 0,&amp;j=4\text{且}i\not=n \\ f_{i-1,j-1}+f_{i-1,j+1},&amp;otherwise \end{cases} \] 其中\(f_{i,j}\)表示坐\(i\)次车到达\(j\)站的方案数。 这个式子线性递推且大小只有\(8\)，矩阵快速幂。 ####USACO2007NovGold Cow Relays 经过\(k\)条边的最短路径。注意到边数\(nE\)不大且每个点度数\(\geq 2\)，因此只需要最多\(2nE\)个点即可，离散化。 ####ZJOI2004 鳄鱼沼泽 仍然是求经过\(k\)条边的路径方案数，不过路径会变。然而变化周期为\(2,3,4\)，因此大周期为\((2,3,4)=12\)就能出现循环。假设第\(i\)个局面的前缀积矩阵为\(G_i\)，则大循环矩阵为\(G_{12}\)，答案矩阵为\(G_{12}^{\lfloor \frac n{12}\rfloor}G_{n \bmod 12}\)。 注意修改矩阵的时候，若\(u\)不能通过，应该将前一个图到达\(u\)的点和该图从\(u\)出发的点置\(0\)才对。 ####BSOJ3792 做梦 令\(f_i\)为\(i\)时间后在家中的方案数，\(g_i\)为\(i\)时间内从家出发走\(i\)步不经过家且最后在家的方案数。则\(f_i=\Sigma_{j=2}^m f_{i-j}g_j\)。发现这个形式线性相关（\(g_j\)可以看作常数），构造矩阵： \[ \begin{bmatrix} g_2 &amp;g_4 &amp;\cdots &amp;g_{m-2} &amp;g_m\\ 1 &amp;0 &amp;\cdots &amp;0 &amp;0\\ 0 &amp;1 &amp;\cdots &amp;0 &amp;0\\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots &amp;\vdots\\ 0 &amp;0 &amp;\cdots &amp;1 &amp;0\\ \end{bmatrix} \begin{bmatrix} f_{i-2}\\ f_{i-4}\\ f_{i-6}\\ \vdots\\ f_{i-m}\\ \end{bmatrix}= \begin{bmatrix} f_i\\ f_{i-2}\\ f_{i-4}\\ \vdots\\ f_{i-m+2}\\ \end{bmatrix} \] 前面的方阵可以快速幂。手推（打表）一下\(g\)就发现是Catalan数。 ####Codeforces719E Sasha and Array 题意：要求支持两种操作：区间Fibonacci和，区间加法。 好题。明显线段树，然而线段树怎么维护值呢。考虑到Fibonacci可以用矩阵快速幂计算，因此我们可以给线段树每个节点都丢一个Fibonacci变换矩阵\(G\)。 不难发现对Fibonacci数列\(f(n)\)有： \[ \begin{aligned} f(n+\Delta)=&amp;G^{n+\Delta} \\ =&amp;G^nG^{\Delta} \\ =&amp;f(n)G^{\Delta} \end{aligned} \] 因此修改值等价于乘变换矩阵的\(\Delta\)次方。又矩阵乘法满足分配率： \[\Sigma_i (f(n_i)G^{\Delta})=G^{\Delta}\Sigma_i f(n_i)\] 因此对一个区间乘上\(G^{\Delta}\)等于对区间和乘上\(G^{\Delta}\)。然后就可以用线段树愉快地维护lazy啦。要注意传\(\Delta\)的时候最好计算好矩阵再传引用，否则时间开销很大。 ###高斯消元 ####JSOI2008 球形空间产生器 假设球心坐标，通过球心到\(n+1\)个点的距离相同可以得到\(n+1\)个方程，且方程右边的数相同。 相邻两个方程分别相减得到\(n\)个\(n\)元一次方程（虽然可以得到更多方程，但是是多余的），用高斯消元即可。 ####BSOJ4544 开关问题 不难发现一个开关要么被开，要么不被开（开两次即以上相当于模\(2\)下的操作），且状态与开关顺序无关。因此我们假设每个开关是否被开，则对灯\(i\)有一个线性方程组，方程组左边为影响\(i\)的开关，方程组右边为灯的末状态和初状态的差值。解异或方程组求自由元个数即可。 ###矩阵树定理 ####SPOJ104 Highways 直接运用定理和高斯消元即可。 ####HEOI2015 小Z的房间 建图求生成树。然而要模\(10^9\)，只能用辗转相除的高斯消元。 ####文艺计算姬 题意：求二分图\((n,m)\)的生成树个数。 矩阵长这样。 \[ \begin{bmatrix} m&amp;0&amp;\cdots&amp;0&amp;-1&amp;-1&amp;\cdots&amp;-1\\ 0&amp;m&amp;\cdots&amp;0&amp;-1&amp;-1&amp;\cdots&amp;-1\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 0&amp;0&amp;\cdots&amp;m&amp;-1&amp;-1&amp;\cdots&amp;-1\\ -1&amp;-1&amp;\cdots&amp;-1&amp;n&amp;0&amp;\cdots&amp;0\\ -1&amp;-1&amp;\cdots&amp;-1&amp;0&amp;n&amp;\cdots&amp;0\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ -1&amp;-1&amp;\cdots&amp;-1&amp;0&amp;0&amp;\cdots&amp;n\\ \end{bmatrix} \] 我们只要\(M_{n+m,n+m}\)，然后消前\(n\)行。 \[ D= \begin{vmatrix} m&amp;0&amp;\cdots&amp;0&amp;-1&amp;-1&amp;\cdots&amp;-1\\ 0&amp;m&amp;\cdots&amp;0&amp;-1&amp;-1&amp;\cdots&amp;-1\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 0&amp;0&amp;\cdots&amp;m&amp;-1&amp;-1&amp;\cdots&amp;-1\\ 0&amp;0&amp;\cdots&amp;0&amp;n-\frac nm&amp;-\frac nm&amp;\cdots&amp;-\frac nm\\ 0&amp;0&amp;\cdots&amp;0&amp;-\frac nm&amp;n-\frac nm&amp;\cdots&amp;-\frac nm\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 0&amp;0&amp;\cdots&amp;0&amp;-\frac nm&amp;-\frac nm&amp;\cdots&amp;n-\frac nm\\ \end{vmatrix} \] 令\(D_1\)和\(D_2\)有： \[ D_1= \begin{vmatrix} m&amp;0&amp;\cdots&amp;0\\ 0&amp;m&amp;\cdots&amp;0\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 0&amp;0&amp;\cdots&amp;m\\ \end{vmatrix} ,D_2= \begin{vmatrix} n-\frac nm&amp;-\frac nm&amp;\cdots&amp;-\frac nm\\ -\frac nm&amp;n-\frac nm&amp;\cdots&amp;-\frac nm\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ -\frac nm&amp;-\frac nm&amp;\cdots&amp;n-\frac nm\\ \end{vmatrix} \] 由于左下角都为\(0\)，因此它们对行列式没有贡献，有贡献的只有左上角和右下角，即\(D=D_1D_2\)。显然\(D_1=m^n\)。我们观察\(D_2\)。 把除了第一行的行都加到第一行上。 \[ D_2= \begin{vmatrix} \frac nm&amp;\frac nm&amp;\cdots&amp;\frac nm\\ -\frac nm&amp;n-\frac nm&amp;\cdots&amp;-\frac nm\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ -\frac nm&amp;-\frac nm&amp;\cdots&amp;n-\frac nm\\ \end{vmatrix} \] 提出第一行的常数： \[ D_2=\frac nm \begin{vmatrix} 1&amp;1&amp;\cdots&amp;1\\ -\frac nm&amp;n-\frac nm&amp;\cdots&amp;-\frac nm\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ -\frac nm&amp;-\frac nm&amp;\cdots&amp;n-\frac nm\\ \end{vmatrix} \] 把第一行乘\(\frac nm\)加到下面： \[ D_2=\frac nm \begin{vmatrix} 1&amp;1&amp;\cdots&amp;1\\ 0&amp;n&amp;\cdots&amp;0 \\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 0&amp;0&amp;\cdots&amp;n\\ \end{vmatrix} \] 显然\(D_2=\frac nm*n^{m-2}=n^{m-1}m^{-1}\)。因此\(D=D_1D_2=n^{m-1}m^{n-1}\)。 另外这道题也可以用prufer序列得到式子： //有空再写 需要快速乘和快速幂。 ##总结 矩阵是线性代数的基础之一，其拥有很多性质，如快速幂给我们一种计算线性递推式的方法，行列式可以进行生成树计数。（虽然还有很多性质没有学习） \(n\)项的线性递推式可以构造一个\(n\times n\)的变换矩阵进行快速幂。如果项中有不能直接从上一次的元素中得到的项（如\(k\)次幂），需要将该项的递推式项也加入矩阵，否则可以直接在变换矩阵里写一个常数转移。 邻接矩阵的\(k\)次幂是一个经过\(k\)条边的方案数矩阵。如果有必要，可以重新定义乘法； 高斯消元有多解时，若某项及之后的式子该项系数全为\(0\)，则需要保持在该行并考察下一项。 行列式求值时，交换两行需要乘\(-1\)。且消元时应该用第\(j\)行减去第\(i\)行作为第\(j\)行的答案。 行列式的六个性质： \(\det(A)=\det(A^T)\) \(\det(A)=-\det(A_{\text{swap(i,j)}})\) \(k\det(a)=\det{A_{A_i=kA_i}}\) 若\(A_i=kA_j\)，则\(\det(A)=0\) 若\(A=B+C\)，则\(\det(A)=\det(B)+\det(C)\) \(\det(A)=\det(A_{A_i=A_i+kA_j})\) 进行行列式化简时，若每一行都刚好有一个元素相同且互不同列，而其他元素也相同，则可以把所有行都加在一行上得到一行相同的数，提出常数得到\(1\)，再依次消元。]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>行列式</tag>
      </tags>
  </entry>
</search>
